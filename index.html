<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MP3 Archive Streamer</title>
    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <!-- jsmediatags Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script>
    <!-- JSZip Library for Multi-Download -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        /* --- Apple Music-inspired Dark Theme --- */
        :root {
            --bg-primary: #121212;
            --bg-secondary: #1e1e1e;
            --bg-tertiary: #282828;
            --text-primary: #ffffff;
            --text-secondary: #b3b3b3;
            --accent-color: #ff375f; /* Pinkish-red */
            --accent-hover: #ff5375;
            --progress-bar: #535353;
            --progress-filled: var(--accent-color);
            --volume-track: #535353;
            --volume-thumb: #ffffff;
            --border-color: #2a2a2a;
            --highlight-color: rgba(255, 55, 95, 0.15);
            --card-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            --player-shadow: 0 -8px 24px rgba(0, 0, 0, 0.7);
            --hint-bg: #282828;
            --hint-text: #e0e0e0;
            --button-bg-hover: rgba(255, 255, 255, 0.1);
            --skeleton-bg: #2a2a2a;
            --skeleton-highlight: #383838;
            --list-item-hover: var(--bg-tertiary);
            --icon-color-default: var(--text-secondary);
            --icon-color-accent: var(--accent-color);
            --icon-color-container: #77aaff; /* Blue for folder/artist/album */
            --download-progress-bg: rgba(255, 255, 255, 0.2);
            --download-progress-fill: var(--accent-color);
            --lyrics-text-color: rgba(255, 255, 255, 0.65);
            --lyrics-active-color: var(--text-primary);
            --grid-artwork-bg: #2a2a2a;
        }

        /* --- Base Styles --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            -webkit-font-smoothing: antialiased;
            transition: padding-bottom 0.3s ease;
        }
        
        body.lyrics-view-active {
            overflow: hidden;
        }
        
        body.lyrics-view-active .container,
        body.lyrics-view-active .header,
        body.lyrics-view-active .controls-bar {
            display: none;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* --- Font Awesome Icon Adjustments --- */
        i.fas, i.far, i.fab {
            vertical-align: middle;
            line-height: 1;
        }

        /* --- Header --- */
        .header { display: flex; justify-content: space-between; align-items: center; padding: 15px 0; border-bottom: 1px solid var(--border-color); margin-bottom: 15px; flex-wrap: wrap; gap: 15px; }
        .header h1 { margin: 0; font-size: 1.8rem; background: linear-gradient(90deg, var(--accent-color), var(--accent-hover)); -webkit-background-clip: text; background-clip: text; color: transparent; flex-shrink: 0; order: 1; }
        .search-area { display: flex; align-items: center; gap: 10px; flex-grow: 1; justify-content: flex-end; order: 3; }
        .header-icon-button { background: none; border: none; color: var(--text-primary); font-size: 1.2rem; cursor: pointer; padding: 8px; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; transition: background-color 0.2s, transform 0.1s ease-out; flex-shrink: 0; line-height: 1; }
        .header-icon-button i { font-size: inherit; }
        .header-icon-button:hover { background-color: var(--button-bg-hover); }
        .header-icon-button:active { transform: scale(0.9); }
        .search-container { position: relative; width: 0; opacity: 0; transition: width 0.35s cubic-bezier(0.25, 0.1, 0.25, 1), opacity 0.3s ease, visibility 0s linear 0.35s; overflow: hidden; visibility: hidden; max-width: 300px; }
        .search-container.active { width: 100%; opacity: 1; visibility: visible; transition: width 0.35s cubic-bezier(0.25, 0.1, 0.25, 1), opacity 0.3s ease, visibility 0s linear 0s; }
        #search-box { width: 100%; padding: 10px 15px 10px 40px; border: none; border-radius: 20px; background-color: var(--bg-tertiary); color: var(--text-primary); font-size: 0.9rem; outline: none; box-sizing: border-box; }
        #search-box::-webkit-search-cancel-button { -webkit-appearance: none; appearance: none; height: 1em; width: 1em; background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512' fill='%23b3b3b3'%3e%3cpath d='M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM175 175c9.4-9.4 24.6-9.4 33.9 0l47 47 47-47c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9l-47 47 47 47c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-47-47-47 47c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l47-47-47-47c-9.4-9.4-9.4-24.6 0-33.9z'/%3e%3c/svg%3e"); background-size: 1em 1em; cursor: pointer; opacity: 0.7; margin-right: 5px; }
        #search-box::-webkit-search-cancel-button:hover { opacity: 1; }
        .search-icon-input { position: absolute; left: 15px; top: 50%; transform: translateY(-50%); color: var(--text-secondary); pointer-events: none; font-size: 1rem; }
        .main-view-toggle { order: 2; display: flex; gap: 5px; background-color: var(--bg-tertiary); padding: 4px; border-radius: 6px; flex-shrink: 0; }
        .main-view-btn { background: none; border: none; color: var(--text-secondary); font-size: 0.85rem; font-weight: 500; cursor: pointer; padding: 4px 10px; border-radius: 4px; transition: background-color 0.2s, color 0.2s; line-height: 1.2; }
        .main-view-btn:hover { color: var(--text-primary); }
        .main-view-btn.active { background-color: var(--bg-secondary); color: var(--text-primary); box-shadow: inset 0 1px 2px rgba(0,0,0,0.3); }

        /* --- Controls Bar --- */
        .controls-bar { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px; margin-bottom: 15px; min-height: 30px; }
        .directory-container { overflow-x: auto; white-space: nowrap; padding-bottom: 5px; flex-grow: 1; min-width: 150px; scrollbar-width: thin; scrollbar-color: var(--bg-tertiary) var(--bg-primary); }
        .directory-container::-webkit-scrollbar { height: 6px; }
        .directory-container::-webkit-scrollbar-track { background: var(--bg-primary); }
        .directory-container::-webkit-scrollbar-thumb { background-color: var(--bg-tertiary); border-radius: 3px; }
        .directory-path { display: inline-flex; gap: 5px; align-items: center; }
        .directory-crumb { color: var(--text-secondary); font-size: 0.9rem; cursor: pointer; transition: color 0.2s, background-color 0.2s; padding: 2px 4px; border-radius: 3px; }
        .directory-crumb:hover { color: var(--text-primary); background-color: var(--bg-tertiary); text-decoration: none; }
        .directory-crumb.current { color: var(--text-primary); font-weight: 500; cursor: default; }
        .directory-crumb.current:hover { background-color: transparent; }
        .directory-separator { color: var(--text-secondary); font-size: 0.9rem; margin: 0 2px; }
        .item-count-display { font-size: 0.8rem; color: var(--text-secondary); margin: 0 10px; white-space: nowrap; flex-shrink: 0; line-height: 1.2; align-self: center; display: none; }
        .view-sort-controls { display: flex; align-items: center; gap: 10px; flex-shrink: 0; }
        .view-toggle-buttons, .sort-buttons { display: flex; gap: 5px; background-color: var(--bg-tertiary); padding: 4px; border-radius: 6px; }
        .view-toggle-btn, .sort-btn { background: none; border: none; color: var(--text-secondary); cursor: pointer; padding: 4px 8px; border-radius: 4px; transition: background-color 0.2s, color 0.2s; line-height: 1; }
        .view-toggle-btn { font-size: 1.1rem; }
        .sort-btn { font-size: 0.9rem; display: flex; align-items: center; gap: 5px; }
        .view-toggle-btn i, .sort-btn i { font-size: 1.1em; }
        .view-toggle-btn:hover, .sort-btn:hover { color: var(--text-primary); }
        .view-toggle-btn.active, .sort-btn.active { background-color: var(--bg-secondary); color: var(--text-primary); box-shadow: inset 0 1px 2px rgba(0,0,0,0.3); }

        /* --- Multi-Download Button --- */
        #download-all-btn { background-color: var(--bg-tertiary); color: var(--text-secondary); border: 1px solid var(--border-color); border-radius: 6px; padding: 5px 10px; font-size: 0.85rem; font-weight: 500; cursor: pointer; display: inline-flex; align-items: center; gap: 6px; transition: all 0.2s; margin-left: 10px; flex-shrink: 0; }
        #download-all-btn:hover:not(:disabled) { background-color: var(--bg-secondary); color: var(--text-primary); }
        #download-all-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        #download-all-btn .icon { font-size: 1em; }
        #download-all-progress-text { font-weight: 400; font-size: 0.8rem; }
        #download-all-btn.loading .icon { display: none; }
        #download-all-btn:not(.loading) #download-all-progress-container { display: none; }
        #download-all-cancel-btn { color: var(--accent-color); margin-left: 8px; font-weight: 700; cursor: pointer; }
        #download-all-cancel-btn:hover { color: var(--accent-hover); }
        #download-all-btn .loader { width: 14px; height: 14px; border-width: 2px; margin-right: 5px; display: none; }
        #download-all-btn.loading .loader { display: inline-block; }

        /* --- Skeleton Loaders --- */
        .skeleton { background-color: var(--bg-secondary); border-color: var(--border-color); pointer-events: none; position: relative; overflow: hidden; }
        .skeleton::before { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: linear-gradient(90deg, transparent, var(--skeleton-highlight), transparent); animation: skeleton-shine 1.3s infinite linear; }
        @keyframes skeleton-shine { 0% { left: -100%; } 100% { left: 100%; } }
        /* Grid Skeleton */
        .file-item-grid.skeleton { display: flex; flex-direction: column; background-color: transparent; padding: 10px; }
        .skeleton-artwork { width: 100%; padding-top: 100%; background-color: var(--skeleton-bg); border-radius: 8px; margin-bottom: 12px; }
        .skeleton-text { width: 80%; height: 1em; background-color: var(--skeleton-bg); border-radius: 3px; margin-bottom: 8px; }
        .skeleton-text.short { width: 50%; height: 0.8em; }
        /* List Skeleton */
        .file-item-list.skeleton { height: 45px; display: flex; align-items: center; gap: 10px; padding: 10px 12px; border-radius: 5px; background-color: var(--skeleton-bg); }
        .file-browser-list .skeleton-icon { width: 20px; height: 20px; margin-bottom: 0; flex-shrink: 0; background-color: var(--skeleton-highlight); border-radius: 3px; }
        .file-browser-list .skeleton-text { height: 0.9em; margin-bottom: 0; flex-grow: 1; background-color: var(--skeleton-highlight); border-radius: 3px; }
        .file-browser-list .skeleton-text.short { width: 50px; flex-grow: 0; flex-shrink: 0; margin-left: auto; background-color: var(--skeleton-highlight); border-radius: 3px; }

        /* --- File Browser Container --- */
        #file-browser-container { margin-top: 10px; }

        /* --- Individual Download Button with Circular Progress --- */
        .track-download-btn { background: none; border: none; color: var(--icon-color-default); font-size: 1.1rem; cursor: pointer; padding: 0; border-radius: 50%; width: 28px; height: 28px; display: inline-flex; align-items: center; justify-content: center; transition: background-color 0.2s, color 0.2s; line-height: 1; flex-shrink: 0; position: relative; }
        .track-download-btn:hover:not(:disabled) { background-color: var(--button-bg-hover); color: var(--text-primary); }
        .track-download-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .track-download-btn .btn-content-wrapper { position: relative; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; }
        .track-download-btn .btn-icon { transition: opacity 0.2s; }
        .track-download-btn .circular-progress { position: absolute; top: 50%; left: 50%; width: 100%; height: 100%; transform: translate(-50%, -50%) rotate(-90deg); display: none; }
        .track-download-btn .progress-background { stroke: var(--download-progress-bg); }
        .track-download-btn .progress-bar-circle { stroke: var(--download-progress-fill); stroke-linecap: round; transition: stroke-dashoffset 0.1s linear; }
        .track-download-btn .download-progress-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 0.55rem; font-weight: bold; color: var(--text-primary); display: none; line-height: 1; }
        .track-download-btn .btn-loader { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 16px; height: 16px; border-width: 2px; border-color: rgba(255, 255, 255, 0.3); border-top-color: var(--text-primary); animation: spin 0.8s linear infinite; }
        .track-download-btn.loading .btn-icon { opacity: 0.1; }
        .track-download-btn.loading .circular-progress,
        .track-download-btn.loading .download-progress-text { display: block; }
        .track-download-btn.loading .btn-loader { display: none; }
        
        /* --- Item-specific Jump to Folder Button (Search only) --- */
        .item-jump-to-folder-btn { background: none; border: none; color: var(--icon-color-default); cursor: pointer; line-height: 1; flex-shrink: 0; position: relative; transition: background-color 0.2s, color 0.2s; }
        .file-item-list .item-jump-to-folder-btn { font-size: 1.1rem; padding: 0; border-radius: 50%; width: 28px; height: 28px; display: inline-flex; align-items: center; justify-content: center; margin-left: 5px; }
        .file-item-list .item-jump-to-folder-btn:hover { background-color: var(--button-bg-hover); color: var(--text-primary); }
        .grid-item-info .item-jump-to-folder-btn { background-color: rgba(255,255,255,0.1); width: 24px; height: 24px; border-radius: 50%; font-size: 0.8rem; display: inline-flex; align-items: center; justify-content: center; padding: 0; }
        .grid-item-info .item-jump-to-folder-btn:hover { background-color: rgba(255,255,255,0.2); color: var(--text-primary); }

        /*
        ========================================
        --- Redesigned Grid View ---
        ========================================
        */
        .file-browser-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 24px; }
        .file-item-grid { background-color: transparent; border-radius: 8px; transition: all 0.2s ease-in-out; position: relative; cursor: pointer; padding: 10px; }
        .file-item-grid:hover { background-color: var(--list-item-hover); }
        .file-item-grid.non-interactive { cursor: default; }
        .file-item-grid.non-interactive:hover { background-color: transparent; }
        
        .grid-item-artwork { position: relative; width: 100%; padding-top: 100%; border-radius: 8px; background-color: var(--grid-artwork-bg); overflow: hidden; margin-bottom: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.4); }
        .grid-item-artwork .cover-art-image { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; transition: transform 0.3s ease; }
        .file-item-grid:hover .cover-art-image { transform: scale(1.05); }
        .grid-item-artwork .icon-fallback { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 3rem; color: var(--icon-color-default); }
        .grid-item-artwork .icon-fallback.folder { color: var(--icon-color-container); }
        .grid-item-artwork .icon-fallback.music { color: var(--icon-color-accent); }
        .grid-item-artwork .icon-fallback.image { color: var(--text-secondary); }

        /* Play overlay for tracks */
        .grid-item-artwork .play-overlay { position: absolute; bottom: 8px; right: 8px; width: 44px; height: 44px; background-color: var(--accent-color); border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-size: 1.2rem; box-shadow: 0 4px 10px rgba(0,0,0,0.5); opacity: 0; transform: translateY(10px) scale(0.9); transition: all 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275); pointer-events: none; }
        .file-item-grid.is-audio:hover .play-overlay { opacity: 1; transform: translateY(0) scale(1); }
        .play-overlay:hover { background-color: var(--accent-hover); transform: scale(1.1) !important; }
        
        .grid-item-info { padding: 0 4px; text-align: left; }
        .file-name-grid { 
            font-size: 0.9rem; font-weight: 600; line-height: 1.3;
            overflow: hidden; 
            display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; 
            max-height: 2.6em; /* 2 * 1.3em */
            transition: max-height 0.3s ease-in-out;
            margin-bottom: 4px; cursor: pointer;
        }
        .file-name-grid.expanded {
            -webkit-line-clamp: unset;
            max-height: 10em; /* Sufficiently large height */
        }
        
        .file-info-grid { font-size: 0.8rem; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: flex; align-items: center; justify-content: space-between; gap: 8px; }

        .file-item-grid.playing-track { background-color: var(--list-item-hover); }
        .file-item-grid.playing-track .file-name-grid { color: var(--accent-color); }
        .file-item-grid.playing-track .play-overlay { opacity: 1; transform: translateY(0) scale(1); background-color: var(--accent-hover); }
        .file-item-grid.playing-track .play-overlay i::before { content: "\f04c"; /* Pause icon */ }

        /*
        ========================================
        --- IMPROVED List View (Standard & Enhanced) ---
        ========================================
        */
         .file-browser-list { display: flex; flex-direction: column; gap: 2px; }
         .file-item-list { display: flex; align-items: center; padding: 10px 12px; background-color: transparent; border-radius: 5px; cursor: default; transition: background-color 0.2s ease-in-out, border-left-color 0.2s ease-in-out; border-left: 3px solid transparent; gap: 12px; }
         .file-item-list:hover { background-color: var(--list-item-hover); }
         .file-item-list.non-interactive { cursor: default; opacity: 0.6; }
         .file-item-list.non-interactive:hover { background-color: transparent; }
         .file-icon-list { font-size: 1.2rem; color: var(--icon-color-accent); line-height: 1; width: 20px; text-align: center; flex-shrink: 0; }
         .file-icon-list.folder { color: var(--icon-color-container); }
         .file-icon-list.image { color: var(--text-secondary); }
         .file-name-list { font-size: 0.95rem; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex-grow: 1; line-height: 1.3; cursor: pointer; transition: color 0.2s ease; }
         .file-item-list.is-folder .file-name-list, .file-item-list.is-image .file-name-list { cursor: pointer; }
         .file-item-list.non-interactive .file-name-list { cursor: default; }
         .file-info-list { display: flex; align-items: center; justify-content: flex-end; gap: 10px; min-width: 100px; text-align: right; flex-shrink: 0; }
         .file-duration-list { font-size: 0.8rem; color: var(--text-secondary); width: 45px; text-align: right; flex-shrink: 0; }
         .file-size-list { font-size: 0.8rem; color: var(--text-secondary); min-width: 55px; text-align: right; flex-shrink: 0; }
         .file-item-count { font-size: 0.8rem; color: var(--text-secondary); margin-left: auto; flex-shrink: 0; padding-left: 15px; }
         .file-item-list .track-download-btn { margin-left: 5px; }
         .file-item-list.playing-track { background-color: var(--highlight-color); border-left-color: var(--accent-color); }
         .file-item-list.playing-track .file-name-list { color: var(--accent-color); font-weight: 600;}

        /* --- NEW: Enhanced List View Specifics --- */
        .file-browser-list.enhanced-view .file-item-list { gap: 15px; }
        .file-item-list-header { display: flex; align-items: center; padding: 5px 12px; margin-bottom: 4px; font-size: 0.75rem; color: var(--text-secondary); border-bottom: 1px solid var(--border-color); font-weight: 500; text-transform: uppercase; letter-spacing: 0.5px; gap: 15px; }
        .file-browser-list.enhanced-view .file-title-list,
        .file-browser-list.enhanced-view .file-artist-list,
        .file-browser-list.enhanced-view .file-name-full-list { font-size: 0.95rem; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; line-height: 1.3; cursor: pointer; }
        .file-browser-list.enhanced-view .is-audio:hover .file-title-list,
        .file-browser-list.enhanced-view .is-folder:hover .file-name-full-list,
        .file-browser-list.enhanced-view .is-image:hover .file-name-full-list { color: var(--text-primary); }
        .file-browser-list.enhanced-view .file-artist-list { color: var(--text-secondary); cursor: default; }
        .file-browser-list.enhanced-view .playing-track .file-title-list { color: var(--accent-color); font-weight: 600; }
        .file-browser-list.enhanced-view .playing-track .file-artist-list { color: var(--accent-hover); }
        .enhanced-view .file-name-list { display: none; } /* Hide original name element */
        
        /* Column sizing for Enhanced View */
        .file-icon-list-header, .enhanced-view .file-icon-list { flex: 0 0 20px; }
        .file-title-list-header, .enhanced-view .file-title-list { flex: 1 1 50%; min-width: 150px; }
        .file-artist-list-header, .enhanced-view .file-artist-list { flex: 1 1 30%; min-width: 120px; }
        .file-name-full-list { flex: 1 1 80%; /* Takes up both title and artist space */ }
        .file-info-list-header, .enhanced-view .file-info-list { flex: 0 0 auto; min-width: 125px; /* Added space for jump button */ justify-content: flex-end;}
        .file-actions-list, .enhanced-view .file-info-list .track-download-btn, .enhanced-view .file-info-list .item-jump-to-folder-btn { width: 28px; }


        /* --- Player Section (Base Desktop Layout) --- */
        #player-section { position: fixed; bottom: 0; left: 0; width: 100%; background-color: rgba(30, 30, 30, 0.9); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); padding: 0; box-shadow: var(--player-shadow); border-top: 1px solid var(--border-color); z-index: 100; transition: height 0.4s ease, transform 0.4s ease, top 0.4s ease, background-color 0.4s ease; height: 90px; overflow: hidden; }
        .player-content-wrapper { display: flex; align-items: center; width: 100%; height: 100%; gap: 10px; transition: opacity 0.3s ease, flex-direction 0.3s ease; padding: 0 20px; box-sizing: border-box; }
        
        .player-column-left { display: flex; align-items: center; justify-content: space-between; flex-grow: 1; min-width: 0; gap: 10px; transition: all 0.4s ease; }
        .player-column-right { display: none; }
        
        .player-info { display: flex; align-items: center; gap: 10px; flex-basis: 30%; flex-shrink: 1; min-width: 180px; overflow: hidden; order: 1; transition: all 0.4s ease; }
        .player-album-art { position: relative; width: 55px; height: 55px; background-color: var(--bg-tertiary); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 1.8rem; flex-shrink: 0; color: var(--icon-color-accent); overflow: hidden; transition: all 0.4s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.3); }
        .player-album-art img { display: block; width: 100%; height: 100%; object-fit: cover; position: absolute; top: 0; left: 0; opacity: 0; transition: opacity 0.3s ease; z-index: 2; }
        .player-album-art img.loaded { opacity: 1; }
        .player-album-art img.loading { opacity: 0; }
        .player-album-art #album-art-icon { position: relative; z-index: 1; transition: opacity 0.3s ease; }
        .player-album-art #album-art-icon.hidden { opacity: 0; }
        .player-album-art .loader-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.75); display: none; align-items: center; justify-content: center; z-index: 3; flex-direction: column; gap: 5px; padding: 5px; box-sizing: border-box; text-align: center; }
        .player-album-art .loader-overlay.visible { display: flex; }
        .player-album-art .loader-overlay .loader { margin: 0; width: 18px; height: 18px; border-width:2px;}
        .player-album-art .loader-overlay .loading-percentage { color: var(--text-primary); font-size: 0.75rem; font-weight: bold; line-height: 1.1; }
        .player-text { min-width: 0; overflow: hidden; flex-grow: 1; transition: all 0.4s ease; }
        .player-title { font-size: 0.95rem; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 2px; transition: all 0.4s ease; }
        .player-subtitle { font-size: 0.8rem; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-weight: 500; transition: all 0.4s ease; }
        .player-subtitle-small { font-size: 0.7rem; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; opacity: 0.8; margin-top: 2px; display: none; transition: all 0.4s ease; }
        .player-info .jump-to-folder-btn { margin-left: 8px; font-size: 1rem; width: 32px; height: 32px; flex-shrink: 0; }

        .player-controls { display: flex; flex-direction: column; align-items: center; gap: 8px; flex-grow: 1; flex-basis: 40%; max-width: 500px; order: 2; transition: all 0.4s ease; }
        .player-buttons { display: flex; align-items: center; gap: 15px; }
        .player-button { background: none; border: none; color: var(--text-primary); font-size: 1.2rem; cursor: pointer; padding: 5px; border-radius: 50%; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; transition: all 0.2s; line-height: 1; position: relative; }
        .player-button i { font-size: inherit; line-height: inherit; }
        .player-button:disabled { opacity: 0.4; cursor: not-allowed; }
        .player-button:not(:disabled):hover { background-color: var(--button-bg-hover); transform: scale(1.05); }
        .player-button:not(:disabled):active { transform: scale(0.95); }
        #download-btn { font-size: 1.1rem; }
        #download-btn .btn-loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 18px; height: 18px; border-width: 2px; display: none; animation: spin 0.8s linear infinite; border-color: rgba(255, 255, 255, 0.3); border-top-color: var(--text-primary); }
        #download-btn.loading .btn-icon { visibility: hidden; }
        #download-btn.loading .btn-loader { display: inline-block; }
        .play-pause-btn { background-color: var(--accent-color); width: 44px; height: 44px; }
        .play-pause-btn:not(:disabled):hover { background-color: var(--accent-hover); transform: scale(1.08); }
        .play-pause-btn:not(:disabled):active { transform: scale(1); }
        .play-pause-btn .fa-play, .play-pause-btn .fa-pause, .play-pause-btn .fa-spinner { font-size: 1.3rem; }
        .progress-container { width: 100%; display: flex; align-items: center; gap: 10px; }
        .progress-time { font-size: 0.75rem; color: var(--text-secondary); min-width: 40px; text-align: center; }
        .progress-bar-wrapper { flex-grow: 1; height: 12px; display: flex; align-items: center; cursor: pointer; padding: 4px 0; }
        .progress-bar-container { width: 100%; height: 4px; background-color: var(--progress-bar); border-radius: 2px; overflow: hidden; position: relative; transition: transform 0.2s ease; }
        .progress-bar { height: 100%; background-color: var(--progress-filled); border-radius: 2px; width: 0%; position: absolute; left: 0; top: 0; transition: width 0.1s linear;}
        .progress-bar-wrapper:hover .progress-bar { background-color: var(--accent-hover); }
        .progress-bar-wrapper:hover .progress-bar-container { transform: scaleY(1.5); }

        .player-extras { display: flex; align-items: center; gap: 10px; flex-basis: 30%; flex-shrink: 1; justify-content: flex-end; min-width: 180px; order: 3; transition: all 0.4s ease; }
        #lyrics-btn { font-size: 1.1rem; }
        .pitch-control { display: flex; align-items: center; gap: 5px; }
        .control-label { font-size: 0.8rem; color: var(--text-secondary); min-width: 35px; text-align: right; }
        .control-slider { width: 70px; height: 4px; appearance: none; background-color: var(--volume-track); border-radius: 2px; outline: none; cursor: pointer; transition: background-color 0.2s; }
        .control-slider:hover { background-color: #6a6a6a; }
        .control-slider::-webkit-slider-thumb { appearance: none; width: 12px; height: 12px; background: var(--volume-thumb); border-radius: 50%; cursor: pointer; transition: transform 0.1s; }
        .control-slider:active::-webkit-slider-thumb { transform: scale(1.2); }
        .control-slider::-moz-range-thumb { width: 12px; height: 12px; background: var(--volume-thumb); border-radius: 50%; cursor: pointer; border: none; }
        .volume-icon { color: var(--text-secondary); font-size: 1rem; width: 20px; text-align: center; }
        .volume-icon i { font-size: inherit; }
        .revert-speed-btn { width: 28px; height: 28px; font-size: 0.9rem; margin-left: 5px; padding: 0; }
        .volume-control { display: flex; align-items: center; gap: 8px; }

        /* --- Minimized Player States --- */
        #player-section.minimized .player-content-wrapper,
        #player-section.super-minimized .player-content-wrapper { display: none; opacity: 0; pointer-events: none; }
        #player-section.minimized { height: 35px; overflow: hidden; }
        #player-section.super-minimized { height: 28px; overflow: hidden; }
        #player-section.minimized .mini-progress,
        #player-section.super-minimized .mini-progress { display: block; }
        #player-section.minimized .player-info { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; padding: 0 15px; background-color: transparent; opacity: 1; pointer-events: auto; z-index: 101; flex-basis: auto; }
        #player-section.minimized .player-album-art,
        #player-section.minimized .jump-to-folder-btn { display: none; }
        #player-section.minimized .player-text { flex-grow: 1; }
        #player-section.minimized .player-title { font-size: 0.9rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        #player-section.minimized .player-subtitle,
        #player-section.minimized .player-subtitle-small { display: none; }

        .player-toggle-button { position: absolute; top: -25px; left: 50%; transform: translateX(-50%); background-color: rgba(40, 40, 40, 0.9); border: 1px solid var(--border-color); border-bottom: none; color: var(--text-secondary); width: 50px; height: 25px; border-radius: 8px 8px 0 0; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1rem; z-index: 101; transition: background-color 0.2s; padding: 0; }
        .player-toggle-button:hover { background-color: var(--bg-tertiary); color: var(--text-primary); }
        .player-toggle-button .toggle-icon { transition: transform 0.3s ease; }
        .mini-title { position: absolute; left: 15px; top: 50%; transform: translateY(-50%); font-size: 0.85rem; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: calc(100% - 70px); display: none; pointer-events: none; line-height: 1.2; align-items: center; }
        #player-section.super-minimized .mini-title { display: flex; pointer-events: auto; }
        #player-section.minimized .mini-title { display: none; }
        .mini-progress { position: absolute; bottom: 0; left: 0; width: 100%; height: 3px; background-color: var(--progress-bar); display: none; z-index: 102; pointer-events: none; }
        .mini-progress::after { content: ''; position: absolute; left: 0; top: 0; height: 100%; background-color: var(--progress-filled); width: var(--progress-width, 0%); transition: width 0.1s linear; }

        /*
        ========================================
        --- NEW: Full Screen Lyrics View Enhancements ---
        ========================================
        */
        #lyrics-background {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 99; /* Below player content, above main page content */
            background-color: var(--bg-primary);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, visibility 0.5s;
            pointer-events: none;
        }
        body.lyrics-view-active #lyrics-background {
            opacity: 1;
            visibility: visible;
        }
        .lyrics-bg-image {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: cover;
            filter: blur(40px) brightness(0.89);
            transform: scale(1.1);
            opacity: 0;
            transition: opacity 0.6s ease-in-out;
        }
        .lyrics-bg-image.loaded {
            opacity: 1;
        }
        body.lyrics-view-active #player-section {
            top: 0; height: 100%; bottom: auto; padding: 0;
            background-color: rgba(0, 0, 0, 0.81); /* Transparent to show bg, with a dark overlay for contrast */
        }
        body.lyrics-view-active .player-column-right {
            background-color: transparent; /* Must be transparent */
        }

        .lyrics-header { display: flex; justify-content: space-between; align-items: center; width: 100%; margin-bottom: 20px; color: var(--text-primary); flex-shrink: 0; }
        .lyrics-header h3 { margin: 0; font-size: 1.5rem; font-weight: 700; }
        #lyrics-view-close-btn { background: none; border: none; font-size: 2rem; color: var(--text-secondary); cursor: pointer; line-height: 1; transition: color 0.2s; padding: 0 10px; }
        #lyrics-view-close-btn:hover { color: var(--text-primary); }
        
        #lyrics-container { 
            height: 100%; width: 100%; overflow-y: auto; text-align: left; 
            scrollbar-width: thin; scrollbar-color: var(--bg-tertiary) transparent; 
            scroll-padding: 45% 0; box-sizing: border-box;
            -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 20%, black 80%, transparent 100%);
            mask-image: linear-gradient(to bottom, transparent 0%, black 20%, black 80%, transparent 100%);
        }
        #lyrics-container::-webkit-scrollbar { width: 8px; }
        #lyrics-container::-webkit-scrollbar-track { background: transparent; }
        #lyrics-container::-webkit-scrollbar-thumb { background-color: var(--bg-tertiary); border-radius: 4px; }
        
        #lyrics-container::before, #lyrics-container::after { content: ''; display: block; height: 45%; }
        
        .lyrics-line, .lyrics-plain { 
            font-size: 2.2rem; font-weight: 700; line-height: 1.4; 
            margin: 0 0 0.8em 0; color: var(--lyrics-text-color); 
            transition: color 0.4s ease, transform 0.4s ease, opacity 0.4s ease, filter 0.4s ease, text-shadow 0.4s ease;
            opacity: 0.65; /* Slightly more visible for blurred text */
            filter: blur(0.8px); /* Inactive lines are blurred */
        }
        .lyrics-line[data-time] { cursor: pointer; } 
        .lyrics-line.active { 
            color: var(--lyrics-active-color);
            transform: scale(1.05); 
            transform-origin: left center;
            opacity: 1; 
            filter: blur(0); /* Active line is sharp */
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.4); /* Soft glow */
        }
        #lyrics-container.plain-text .lyrics-plain { font-size: 1.2rem; line-height: 1.7; font-weight: 500; opacity: 0.9; white-space: pre-wrap; filter: none; }
        #lyrics-container.plain-text::before, #lyrics-container.plain-text::after { display: none; }
        .lyrics-status { color: var(--text-secondary); font-style: italic; font-size: 1.2rem; filter: none; }

        /* Full Screen Lyrics View Layout */
        body.lyrics-view-active .player-toggle-button, body.lyrics-view-active .mini-progress, body.lyrics-view-active .mini-title { display: none !important; }
        body.lyrics-view-active .player-content-wrapper { flex-direction: row; height: 100%; padding: 0; align-items: stretch; }
        body.lyrics-view-active .player-column-left { flex: 0 0 35%; max-width: 450px; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 25px; padding: 40px; box-sizing: border-box; }
        body.lyrics-view-active .player-column-right { flex: 1 1 65%; display: flex; flex-direction: column; box-sizing: border-box; padding: 40px 60px; }
        body.lyrics-view-active .player-info { flex-direction: column; text-align: center; flex-basis: auto; width: 100%; max-width: 400px; gap: 15px; flex-shrink: 0; }
        body.lyrics-view-active .player-album-art { width: 100%; height: auto; padding-top: 100%; max-width: 400px; border-radius: 12px; }
        body.lyrics-view-active .player-text { text-align: center; overflow: visible; }
        body.lyrics-view-active .player-title { font-size: 1.6rem; white-space: normal; line-height: 1.2; }
        body.lyrics-view-active .player-subtitle { font-size: 1.1rem; white-space: normal; margin-top: 4px; line-height: 1.3; }
        body.lyrics-view-active .jump-to-folder-btn,
        body.lyrics-view-active #lyrics-btn { display: none; }
        body.lyrics-view-active .player-controls,
        body.lyrics-view-active .player-extras { flex-basis: auto; width: 100%; max-width: 400px; }
        body.lyrics-view-active .player-extras { justify-content: space-evenly; }
        body.lyrics-view-active .pitch-control, 
        body.lyrics-view-active .volume-control { flex-grow: 1; justify-content: center; }

        /* --- Status Messages & Loader --- */
        .status-message { margin-bottom: 20px; text-align: center; padding: 20px; color: var(--text-secondary); font-size: 1rem; border-radius: 8px; background-color: var(--bg-secondary); border: 1px dashed var(--border-color); display: none; }
        .status-message.visible { display: block; }
        .status-message .loader { margin-right: 10px; }
        .loader { display: inline-block; width: 20px; height: 20px; border: 3px solid rgba(255, 255, 255, 0.2); border-radius: 50%; border-top-color: var(--accent-color); animation: spin 0.8s ease-in-out infinite; vertical-align: middle; }
        @keyframes spin { to { transform: rotate(360deg); } }

         /* --- Search Hint Popup --- */
         #search-hint-popup { position: fixed; bottom: 20px; right: 20px; background-color: var(--hint-bg); color: var(--hint-text); padding: 10px 15px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4); z-index: 101; display: none; align-items: center; gap: 10px; font-size: 0.85rem; opacity: 0; transform: translateY(10px); transition: opacity 0.3s ease, transform 0.3s ease; }
         #search-hint-popup.visible { display: flex; opacity: 1; transform: translateY(0); }
         #close-hint-btn { background: none; border: none; color: var(--text-secondary); font-size: 1.2rem; cursor: pointer; padding: 0 5px; line-height: 1; margin-left: 5px; }
         #close-hint-btn:hover { color: var(--text-primary); }
         kbd { background-color: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 3px; padding: 1px 4px; font-family: monospace; font-size: 0.9em; box-shadow: inset 0 -1px 0 var(--border-color); color: var(--text-primary); }

        /* Exit Search Button in Breadcrumbs */
        .exit-search-btn { background-color: var(--bg-tertiary); color: var(--text-secondary); border: 1px solid var(--border-color); border-radius: 4px; padding: 3px 8px; font-size: 0.8rem; cursor: pointer; display: inline-flex; align-items: center; gap: 5px; transition: background-color 0.2s, color 0.2s; }
        .exit-search-btn:hover { background-color: var(--bg-secondary); color: var(--text-primary); }
        .exit-search-btn i { font-size: 0.9em; }

        /* --- NEW: Image Viewer Modal --- */
        #image-viewer-modal {
            display: none; position: fixed; z-index: 1000;
            left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: rgba(0,0,0,0.85);
            backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);
            animation: fadeIn 0.3s ease;
        }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        #image-viewer-modal .modal-content {
            margin: auto; display: block;
            max-width: 90%; max-height: 80vh;
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 8px; box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #image-viewer-modal .close-btn {
            position: absolute; top: 15px; right: 35px;
            color: #f1f1f1; font-size: 40px; font-weight: bold;
            transition: 0.3s; cursor: pointer;
        }
        #image-viewer-modal .close-btn:hover,
        #image-viewer-modal .close-btn:focus { color: var(--text-secondary); text-decoration: none; }
        #image-viewer-modal #image-viewer-caption {
            position: absolute; bottom: 30px; left: 50%;
            transform: translateX(-50%);
            text-align: center; color: var(--text-secondary);
            font-size: 0.9rem; padding: 10px;
            background: rgba(0,0,0,0.5); border-radius: 4px;
        }
        #image-viewer-modal #image-viewer-download {
            position: absolute; top: 20px; left: 20px;
            background-color: var(--bg-tertiary); color: var(--text-primary);
            padding: 8px 12px; text-decoration: none; border-radius: 5px;
            font-size: 0.9rem; transition: 0.3s;
        }
        #image-viewer-modal #image-viewer-download:hover { background-color: var(--bg-secondary); }

        /* --- Responsive Body Padding --- */
        body.player-standard { padding-bottom: 90px; }
        body.player-minimized { padding-bottom: 35px; }
        body.player-super-minimized { padding-bottom: 28px; }
        body.lyrics-view-active { padding-bottom: 0 !important; }

        @media (max-width: 1024px) {
            .file-browser-grid { grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); }
             body.lyrics-view-active .player-column-left { flex-basis: 35%; max-width: 400px; }
             body.lyrics-view-active .player-column-right { flex-basis: 65%; padding: 30px 40px; }
             .lyrics-line, .lyrics-plain { font-size: 1.8rem; }
        }

        @media (max-width: 768px) {
            body.player-standard { padding-bottom: calc(180px + 25px); }
            body.player-minimized { padding-bottom: calc(35px + 25px); }
            body.player-super-minimized { padding-bottom: calc(28px + 25px); }

            #player-section { height: 180px; }
            #player-section.minimized { height: 35px; }
            #player-section.super-minimized { height: 28px; }

            .player-content-wrapper { flex-direction: column; padding: 10px 15px; gap: 8px; justify-content: space-around; }
            .player-column-left { flex-direction: column; }
            .player-info { order: 1; width: 100%; gap: 10px; flex-basis: auto; justify-content: flex-start; min-width: 0; padding-bottom: 5px; flex-direction: row; }
            .player-info .jump-to-folder-btn { display: flex !important; margin-left: auto; }
            .player-album-art { width: 45px; height: 45px; }
            .player-text { flex-grow: 1; min-width: 0; text-align: left; }
            .player-title, .player-subtitle, .player-subtitle-small { white-space: normal; overflow-wrap: break-word; display: block; line-height: 1.3; }
            .player-title { font-size: 0.9rem; margin-bottom: 1px; }
            .player-subtitle { font-size: 0.75rem; margin-bottom: 1px; }
            .player-subtitle-small { font-size: 0.7rem; opacity: 0.7; display: block; }

            .player-controls { order: 2; width: 100%; display: flex; flex-direction: column; align-items: center; gap: 10px; flex-basis: auto; max-width: none; }
            .player-controls .player-buttons { display: flex; justify-content: center; align-items: center; gap: 15px; width: auto; }
            .player-controls .progress-container { display: flex; width: 100%; align-items: center; gap: 8px; padding: 5px 0; }
            .player-extras { order: 3; width: 100%; justify-content: space-evenly; flex-wrap: wrap; gap: 10px 15px; padding-top: 5px; align-items: center; flex-basis: auto; min-width: 0; }
            .pitch-control, .volume-control { flex-basis: auto; flex-grow: 1; min-width: 130px; justify-content: center; }
            .control-slider { width: 100px; }
            .revert-speed-btn { width: 30px; height: 30px; font-size: 0.9rem; }
            #player-section.super-minimized .mini-title { max-width: calc(100% - 70px); }
            
            body.lyrics-view-active .player-column-left { display: none; }
            body.lyrics-view-active .player-column-right { flex: 1 1 100%; padding: 20px; }
            body.lyrics-view-active .player-info { flex-direction: column; text-align: center; }
            body.lyrics-view-active .player-album-art { width: 250px; height: 250px; padding-top: 0; }
            .lyrics-line, .lyrics-plain { font-size: 1.3rem; }
        }

         @media (max-width: 480px) {
             .file-browser-grid { grid-template-columns: repeat(auto-fill, minmax(130px, 1fr)); gap: 15px; }
             body.player-standard { padding-bottom: calc(185px + 25px); }
             #player-section { height: 185px; }
             .player-content-wrapper { padding: 8px 12px; gap: 6px; }
             .player-album-art { width: 40px; height: 40px; }
             .player-info { gap: 8px; padding-bottom: 3px; }
             .player-info .jump-to-folder-btn { width: 28px; height: 28px; font-size: 0.8rem; }
             .player-title { font-size: 0.85rem; }
             .player-subtitle { font-size: 0.7rem; }
             .player-subtitle-small { font-size: 0.65rem; }
             .player-controls { gap: 8px; }
             .player-controls .player-buttons { gap: 12px; }
             .player-button { width: 34px; height: 34px; font-size: 1rem; }
             .play-pause-btn { width: 40px; height: 40px; }
             .play-pause-btn i { font-size: 1.1rem; }
             .player-controls .progress-container { padding: 3px 0; }
             .player-extras { gap: 8px 12px; padding-top: 3px; }
             .pitch-control, .volume-control { min-width: 120px; gap: 6px;}
             .control-slider { width: 90px; }
             .revert-speed-btn { width: 28px; height: 28px; font-size: 0.8rem; }
             .directory-container { min-width: 80px; }
             .item-count-display { margin: 0 5px; font-size: 0.7rem; }
             
             body.lyrics-view-active .player-album-art { width: 200px; height: 200px; }
             .lyrics-line, .lyrics-plain { font-size: 1.1rem; }
             body.lyrics-view-active .player-column-right { padding: 15px; }
         }
    </style>
</head>
<body class="player-standard">
    <!-- NEW: Element for immersive lyrics background -->
    <div id="lyrics-background"></div>

    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>MP3 Archive</h1>
             <div class="main-view-toggle">
                 <button id="folder-view-btn" class="main-view-btn active" title="Browse by Folder">Folders</button>
             </div>
            <div class="search-area">
                 <button id="search-toggle-btn" class="header-icon-button" title="Search Files (/)"><i class="fas fa-search"></i></button>
                 <div class="search-container" id="search-container">
                     <span class="search-icon-input"><i class="fas fa-search"></i></span>
                     <input type="search" id="search-box" placeholder="Search all files...">
                 </div>
            </div>
        </div>

        <!-- Controls Bar -->
        <div class="controls-bar">
            <div class="directory-container">
                <div class="directory-path" id="directory-path"></div>
            </div>
            <span id="item-count-display" class="item-count-display"></span>
            <div class="view-sort-controls">
                <div class="sort-buttons" id="sort-buttons-container">
                    <button id="sort-alpha-btn" class="sort-btn active" title="Sort Alphabetically (A-Z)">
                        <i class="fas fa-sort-alpha-down"></i> A-Z
                    </button>
                    <button id="sort-year-btn" class="sort-btn" title="Sort by Year (Newest First)">
                        <i class="fas fa-calendar-alt"></i> Year
                    </button>
                </div>
                <!-- NEW: Grid/List toggle container is now controlled by JS -->
                <div class="view-toggle-buttons" id="grid-list-toggle-container" style="display: none;">
                    <button id="grid-view-btn" class="view-toggle-btn" title="Grid View"><i class="fas fa-th-large"></i></button>
                    <button id="list-view-btn" class="view-toggle-btn active" title="List View"><i class="fas fa-list"></i></button>
                </div>
            </div>
            <!-- Multi-Download Button -->
            <button id="download-all-btn" title="Download all items in this view as a ZIP" disabled>
                <span class="icon"><i class="fas fa-file-archive"></i></span>
                <span id="download-all-progress-container">
                    <span class="loader"></span>
                    <span id="download-all-progress-text"></span>
                    <span id="download-all-cancel-btn" title="Cancel Download">&times;</span>
                </span>
            </button>
        </div>
        <!-- Status Message -->
        <div id="status-message" class="status-message"></div>

        <!-- Skeleton Loader -->
        <div id="skeleton-loader" class="file-browser-grid" style="display: none;">
            <!-- Content generated by JS -->
        </div>

        <!-- File Browser -->
        <div id="file-browser-container"></div>
    </div>

    <!-- Player Section -->
    <div id="player-section">
        <button id="player-toggle-btn" class="player-toggle-button" title="Minimize Player">
            <span class="toggle-icon"><i class="fas fa-angle-down"></i></span>
        </button>
        <span id="mini-title" class="mini-title"></span>
        <div id="mini-progress-bar" class="mini-progress"></div>

        <div class="player-content-wrapper">
            <div class="player-column-left">
                <div class="player-info">
                    <div class="player-album-art" id="player-album-art">
                        <img id="album-art-img" src="" alt="Album Art" />
                        <span id="album-art-icon"><i class="fas fa-music"></i></span>
                        <div class="loader-overlay">
                            <span class="loader"></span>
                            <span class="loading-percentage">0%</span>
                        </div>
                    </div>
                    <div class="player-text">
                        <div id="now-playing" class="player-title" title="Not playing">Not playing</div>
                        <div id="now-playing-artist-album" class="player-subtitle" title="Select an MP3 file">Select an MP3 file</div>
                        <div id="now-playing-path" class="player-subtitle-small"></div>
                    </div>
                    <button class="player-button jump-to-folder-btn" id="jump-to-folder-btn" title="Go to track's folder" disabled>
                        <i class="fas fa-folder-open"></i>
                    </button>
                </div>

                <div class="player-controls">
                     <div class="player-buttons">
                        <button class="player-button" id="prev-btn" disabled title="Previous Track (Shift+←)"><i class="fas fa-step-backward"></i></button>
                        <button id="play-pause-btn" class="player-button play-pause-btn" disabled title="Play/Pause (Space)"><i class="fas fa-play"></i></button>
                        <button class="player-button" id="next-btn" disabled title="Next Track (Shift+→)"><i class="fas fa-step-forward"></i></button>
                        <button class="player-button" id="download-btn" title="Download current track" disabled>
                            <span class="btn-icon"><i class="fas fa-download"></i></span>
                            <span class="loader btn-loader"></span>
                        </button>
                    </div>
                    <div class="progress-container">
                        <span id="current-time" class="progress-time">0:00</span>
                        <div class="progress-bar-wrapper" id="progress-wrapper">
                            <div class="progress-bar-container">
                                <div class="progress-bar" id="progress-bar"></div>
                            </div>
                        </div>
                        <span id="duration" class="progress-time">0:00</span>
                    </div>
                </div>

                <div class="player-extras">
                     <div class="pitch-control">
                        <span class="control-label">Speed</span>
                        <input type="range" class="control-slider pitch-slider" id="pitch-slider" min="0.5" max="2" step="0.05" value="1" disabled>
                        <button class="player-button revert-speed-btn" id="revert-speed-btn" title="Reset Speed to 1x" disabled>
                            <i class="fas fa-undo"></i>
                        </button>
                    </div>
                    <div class="volume-control">
                        <span class="volume-icon" id="volume-icon"><i class="fas fa-volume-up"></i></span>
                        <input type="range" class="control-slider volume-slider" id="volume-slider" min="0" max="1" step="0.05" value="0.7">
                    </div>
                     <button class="player-button" id="lyrics-btn" title="Show Lyrics" disabled>
                        <i class="fas fa-align-left"></i>
                    </button>
                </div>
            </div>
            <div class="player-column-right" id="lyrics-display-area">
                <div class="lyrics-header">
                    <h3>Lyrics</h3>
                    <button id="lyrics-view-close-btn" title="Close Lyrics View">&times;</button>
                </div>
                <div id="lyrics-container">
                    <p class="lyrics-status">Lyrics will appear here.</p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- NEW: Image Viewer Modal -->
    <div id="image-viewer-modal">
      <span class="close-btn" id="image-viewer-close">&times;</span>
      <img class="modal-content" id="image-viewer-img">
      <div id="image-viewer-caption"></div>
      <a id="image-viewer-download" href="#" target="_blank" download>
        <i class="fas fa-download"></i> Download
      </a>
    </div>

    <audio id="audio-element-for-context" style="display: none;"></audio>
    <div id="search-hint-popup">
         <span>Tip: Tap <i class="fas fa-search"></i> or press <kbd>/</kbd> to search</span>
         <button id="close-hint-btn" title="Dismiss hint"><i class="fas fa-times"></i></button>
    </div>

    <script>
        // --- Configuration ---
        const archiveIdentifier = 'aimpthree';
        const archiveApiUrl = `https://archive.org/metadata/${archiveIdentifier}`;
        const archiveDownloadUrlBase = `https://archive.org/download/${archiveIdentifier}`;
        const lyricsApiUrl = 'https://lrclib.net/api'; // UPDATED base URL for lyrics
        const FETCH_TIMEOUT_MS = 40000;
        const MAX_RETRIES = 2;
        const MAX_CACHE_SIZE = 20;
        const SEEK_TIME_SECONDS = 5;
        const UNKNOWN_ARTIST = "[Unknown Artist]";
        const UNKNOWN_ALBUM = "[Unknown Album]";

        // --- DOM Elements ---
        const bodyEl = document.body;
        const searchToggleBtn = document.getElementById('search-toggle-btn');
        const searchContainer = document.getElementById('search-container');
        const searchBox = document.getElementById('search-box');
        const directoryPathEl = document.getElementById('directory-path');
        const fileBrowserContainerEl = document.getElementById('file-browser-container');
        const skeletonLoaderEl = document.getElementById('skeleton-loader');
        const statusMessageEl = document.getElementById('status-message');
        const playerSection = document.getElementById('player-section');
        const playerToggleBtn = document.getElementById('player-toggle-btn');
        const miniProgressBar = document.getElementById('mini-progress-bar');
        const miniTitleEl = document.getElementById('mini-title');
        const playerAlbumArt = document.getElementById('player-album-art');
        const albumArtImg = document.getElementById('album-art-img');
        const albumArtIcon = document.getElementById('album-art-icon');
        const albumArtLoader = playerAlbumArt.querySelector('.loader-overlay');
        const albumArtLoadingPercentageEl = playerAlbumArt.querySelector('.loading-percentage');
        const nowPlayingEl = document.getElementById('now-playing');
        const nowPlayingArtistAlbumEl = document.getElementById('now-playing-artist-album');
        const nowPlayingPathEl = document.getElementById('now-playing-path');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const playPauseIcon = playPauseBtn.querySelector('i');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const downloadBtn = document.getElementById('download-btn');
        const jumpToFolderBtn = document.getElementById('jump-to-folder-btn');
        const progressWrapper = document.getElementById('progress-wrapper');
        const progressBar = document.getElementById('progress-bar');
        const currentTimeEl = document.getElementById('current-time');
        const durationEl = document.getElementById('duration');
        const volumeSlider = document.getElementById('volume-slider');
        const volumeIcon = document.getElementById('volume-icon').querySelector('i');
        const pitchSlider = document.getElementById('pitch-slider');
        const revertSpeedBtn = document.getElementById('revert-speed-btn');
        const searchHintPopup = document.getElementById('search-hint-popup');
        const closeHintBtn = document.getElementById('close-hint-btn');
        const gridViewBtn = document.getElementById('grid-view-btn');
        const listViewBtn = document.getElementById('list-view-btn');
        const gridListToggleContainer = document.getElementById('grid-list-toggle-container');
        const folderViewBtn = document.getElementById('folder-view-btn');
        const itemCountDisplayEl = document.getElementById('item-count-display');
        const lyricsBtn = document.getElementById('lyrics-btn');
        const lyricsContainer = document.getElementById('lyrics-container');
        const lyricsViewCloseBtn = document.getElementById('lyrics-view-close-btn');
        const lyricsBackgroundEl = document.getElementById('lyrics-background');
        const downloadAllBtn = document.getElementById('download-all-btn');
        const downloadAllProgressTextEl = document.getElementById('download-all-progress-text');
        const downloadAllCancelBtn = document.getElementById('download-all-cancel-btn');
        const sortAlphaBtn = document.getElementById('sort-alpha-btn');
        const sortYearBtn = document.getElementById('sort-year-btn');
        const sortButtonsContainer = document.getElementById('sort-buttons-container');
        const imageViewerModal = document.getElementById('image-viewer-modal');
        const imageViewerImg = document.getElementById('image-viewer-img');
        const imageViewerCaption = document.getElementById('image-viewer-caption');
        const imageViewerClose = document.getElementById('image-viewer-close');
        const imageViewerDownload = document.getElementById('image-viewer-download');

        // --- Audio State ---
        let audioContext;
        let sourceNode;
        let gainNode;
        let currentAudioBuffer;
        let isPlaying = false;
        let currentPlaybackRate = 1.0;
        let currentVolume = 0.7;
        let progressUpdateInterval;
        let _startTime = 0;
        let _startOffset = 0;
        let _pausedTime = 0;
        let fetchAbortController = null;
        const activeDownloads = new Map();
        let multiDownloadAbortController = null;

        // --- Data State ---
        let currentDirectory = '';
        let allArchiveFiles = [];
        let coverMap = new Map();
        let currentDirectoryItems = [];
        let currentTracklist = [];
        let currentTrackIndex = -1;
        let currentPlayingFile = null;
        let currentLayoutMode = 'list'; // Default layout mode
        let currentSortMode = 'alphabetical';
        let currentMainView = 'folder';
        let playerState = 'super-minimized';
        let isNavigatingViaPopState = false;
        let isLyricsViewActive = false;
        let currentLyrics = null;
        let lastActiveLyricIndex = -1;
        let searchDebounceTimeout;

        // --- Caching ---
        const audioCache = new Map();
        const cacheOrder = [];

        // --- NEW: Performance Constants & Helpers ---
        const PROCESSING_CHUNK_SIZE = 1000; // Process 1000 files before yielding to prevent freezing
        const yieldToMainThread = () => new Promise(resolve => setTimeout(resolve, 0));

        // --- Constants ---
        const VIEW_MODE_FOLDER = 'folder';
        const SEARCH_CHUNK_SIZE = 100;
        const SEARCH_DEBOUNCE_MS = 250;
        const SUBFOLDER_DEFAULT_VIEW = 'grid'; // Default for non-music subfolders

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            const initialPathFromUrl = new URLSearchParams(window.location.search).get('path');
            if (initialPathFromUrl !== null) {
                currentDirectory = initialPathFromUrl;
            }
            history.replaceState({ path: currentDirectory }, document.title, buildUrlQuery(currentDirectory));

            loadSettings();
            setupAudioContext();
            loadArchiveStructure();
            setupEventListeners();
            applySortModeUI();
            applyMainViewMode();
            applyPlayerState();
            showSearchHintIfNeeded();
        });

        function buildUrlQuery(path) {
            return path ? `?path=${encodeURIComponent(path)}` : window.location.pathname;
        }

        function populateSkeletonLoaders() {
            const layout = currentLayoutMode;
            const gridSkeletonHTML = `<div class="file-item-grid skeleton"><div class="skeleton-artwork"></div><div class="skeleton-text"></div><div class="skeleton-text short"></div></div>`;
            const listSkeletonHTML = `<div class="file-item-list skeleton"><div class="skeleton-icon"></div><div class="skeleton-text"></div><div class="skeleton-text short"></div></div>`;
            let skeletonsHTML = '';
            const numSkeletons = 12;

            if (layout === 'grid') {
                for (let i = 0; i < numSkeletons; i++) skeletonsHTML += gridSkeletonHTML;
                skeletonLoaderEl.innerHTML = skeletonsHTML;
                skeletonLoaderEl.className = 'file-browser-grid';
            } else {
                for (let i = 0; i < numSkeletons; i++) skeletonsHTML += listSkeletonHTML;
                skeletonLoaderEl.innerHTML = skeletonsHTML;
                skeletonLoaderEl.className = 'file-browser-list';
            }
        }

        function loadSettings() {
             currentVolume = parseFloat(localStorage.getItem('playerVolume') || '0.7');
             currentPlaybackRate = parseFloat(localStorage.getItem('playerRate') || '1.0');
             playerState = localStorage.getItem('playerState') || 'super-minimized';
             currentSortMode = localStorage.getItem('sortMode') || 'alphabetical';
             currentMainView = localStorage.getItem('mainView') || 'folder';
             volumeSlider.value = currentVolume;
             pitchSlider.value = currentPlaybackRate;
             updateVolumeIcon(currentVolume);
        }

        function saveSetting(key, value) {
             try { localStorage.setItem(key, value); }
             catch (e) { console.warn(`Could not save setting ${key}:`, e); }
        }

        function setupAudioContext() {
            const initAudio = () => {
                if (!audioContext) {
                    try {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        gainNode = audioContext.createGain();
                        gainNode.gain.value = currentVolume;
                        gainNode.connect(audioContext.destination);
                        document.removeEventListener('pointerdown', initAudio);
                        document.removeEventListener('keydown', initAudio);
                    } catch (e) {
                        console.error("Error creating AudioContext:", e);
                        displayStatus(`Web Audio API setup failed. ${sanitizeErrorMessage(e.message, "AudioContext creation")}`, true);
                    }
                }
            };
            document.addEventListener('pointerdown', initAudio, { once: true });
            document.addEventListener('keydown', initAudio, { once: true });
        }

        async function loadArchiveStructure() {
            showInitialLoading();
            try {
                const response = await fetch(archiveApiUrl);
                if (!response.ok) throw new Error(`Metadata fetch failed (Status: ${response.status})`);
                const data = await response.json();
                if (!data.files || !Array.isArray(data.files)) throw new Error('Invalid archive structure: No files array found.');
                
                // *** FIX: Await the new async processing function ***
                let processedFiles = await processRawFiles(data.files);
                
                [allArchiveFiles, coverMap] = mapCoverArtAndGetMap(processedFiles);
                
                updateDirectoryView(currentDirectory);
                updateMainViewToggleButtons();
                hideInitialLoading();
            } catch (error) {
                console.error('Error loading archive:', error);
                displayStatus(`Error loading archive. ${sanitizeErrorMessage(error.message, `Archive metadata fetch`)}`, true);
                hideInitialLoading();
            }
        }

        function sanitizeErrorMessage(message, contextInfo = "") {
            let userMessage = "An error occurred.";
            const originalFullError = `Original error context: ${contextInfo} | Message: ${message}`;
            console.error(originalFullError);
            if (typeof message !== 'string') message = "Internal error detail unavailable.";
            const lowerMessage = message.toLowerCase();
            if (lowerMessage.includes("http") || lowerMessage.includes("status:") || lowerMessage.includes("failed to fetch") || lowerMessage.includes("networkerror")) {
                userMessage = "Network problem: Could not load required data.";
            } else if (lowerMessage.includes("decodeaudio") || lowerMessage.includes("decode")) {
                userMessage = "Audio format error: Could not decode the audio file.";
            } else if (lowerMessage.includes("aborted") || lowerMessage.includes("abort") || lowerMessage.includes("timeout")) {
                userMessage = "Operation timed out or was cancelled. Please check your connection and try again.";
            } else {
                userMessage = "An unexpected issue occurred. Please try again later.";
            }
            return userMessage;
        }
        
        function mapCoverArtAndGetMap(files) {
            const newCoverMap = new Map();
            const coverRegex = /\/(cover|folder)\.(jpe?g|png|webp)$/i;

            for (const file of files) {
                if (file.isImage && coverRegex.test(file.path)) {
                    const dirPath = file.path.substring(0, file.path.lastIndexOf('/') + 1);
                    if (!newCoverMap.has(dirPath) || file.path.toLowerCase().includes('cover.')) {
                       newCoverMap.set(dirPath, file.path);
                    }
                }
            }

            for (const file of files) {
                if (file.isDirectory && newCoverMap.has(file.path)) {
                    file.coverArt = newCoverMap.get(file.path);
                }
            }
            return [files, newCoverMap];
        }
        
        function parseFileName(filename) {
            const mp3Regex = /^(.*?)\s+-\s+(.*?)\s*\.mp3$/i;
            const match = filename.match(mp3Regex);
            if (match && match[1] && match[2]) {
                // Successfully parsed "Artist - Title"
                return { artist: match[1].trim(), title: match[2].trim() };
            }
            // Fallback: Use the whole filename (without extension) as the title
            const title = filename.replace(/\.mp3$/i, '').trim();
            return { artist: null, title: title };
        }

        // *** FIX: HIGH-PERFORMANCE, NON-BLOCKING FILE PROCESSING ***
        async function processRawFiles(rawFiles) {
            const yearRegex = /\((\d{4})\)$/;
            const processedFiles = [];
            const directorySet = new Set();
            const totalFiles = rawFiles.length;

            // --- Step 1: Efficiently find all directories first (O(n)) ---
            // This is a pre-computation step to avoid the O(n^2) loop later.
            for (let i = 0; i < totalFiles; i++) {
                const path = rawFiles[i].name;
                if (path.includes('/')) {
                    // Extract the parent directory path and add it to our Set
                    const parentPath = path.substring(0, path.lastIndexOf('/') + 1);
                    directorySet.add(parentPath);
                }

                // Give the browser a chance to breathe during this initial scan
                if (i % PROCESSING_CHUNK_SIZE === 0) {
                    await yieldToMainThread();
                }
            }
            
            // --- Step 2: Process each file with fast directory lookups (O(n)) ---
            for (let i = 0; i < totalFiles; i++) {
                const file = rawFiles[i];
                const path = file.name;

                // Our new, super-fast directory check. O(1) lookup time.
                const isDirectory = directorySet.has(path);

                const isAudio = !isDirectory && path.toLowerCase().endsWith('.mp3');
                const isImage = !isDirectory && path.toLowerCase().match(/\.(jpe?g|png|webp|gif)$/i);

                // Only include items we actually want to display
                if (!isDirectory && !isAudio && !isImage) {
                    continue;
                }
                
                let displayName = path.split('/').filter(p => p).pop() || path;
                if (isDirectory) {
                    // For directories, the display name is the last part without the trailing slash
                    displayName = path.slice(0, -1).split('/').pop();
                }

                const yearMatch = displayName.match(yearRegex);
                const year = yearMatch ? parseInt(yearMatch[1], 10) : null;
                let durationSeconds = file.length && !isNaN(parseFloat(file.length)) ? parseFloat(file.length) : undefined;

                let apiArtist = (file.creator || file.artist || '').split(';')[0].trim() || null;
                let apiAlbum = (file.album || '').split('g;')[0].trim() || null;
                let apiTitle = file.title || null;

                let parsedData = { title: displayName.replace(/\.mp3$/i, ''), artist: null };
                if (isAudio) {
                    parsedData = parseFileName(displayName);
                }

                processedFiles.push({
                    name: file.name, path: path, size: file.size ? parseInt(file.size) : 0, format: file.format || '',
                    isDirectory, isAudio, isImage, displayName, duration: durationSeconds, year,
                    title: apiTitle || parsedData.title,
                    artist: apiArtist || parsedData.artist,
                    album: apiAlbum,
                    metadata: null, coverArt: null
                });

                // The magic "no-freeze" part.
                if (i % PROCESSING_CHUNK_SIZE === 0) {
                    // Update the loading message to show progress
                    statusMessageEl.innerHTML = `<span class="loader"></span>Processing archive... (${Math.round((i / totalFiles) * 100)}%)`;
                    // Yield to the main thread
                    await yieldToMainThread();
                }
            }

            return processedFiles;
        }

        function showInitialLoading() { populateSkeletonLoaders(); showSkeletonLoader(true); statusMessageEl.innerHTML = `<span class="loader"></span>Loading archive... Please wait.`; statusMessageEl.classList.add('visible'); fileBrowserContainerEl.innerHTML = ''; if (itemCountDisplayEl) itemCountDisplayEl.style.display = 'none'; }
        function hideInitialLoading() { hideSkeletonLoader(); if (statusMessageEl.textContent.includes("Loading archive") || statusMessageEl.textContent.includes("Processing archive")) { statusMessageEl.classList.remove('visible'); statusMessageEl.innerHTML = ''; } }
        function showSkeletonLoader(show) { populateSkeletonLoaders(); skeletonLoaderEl.style.display = show ? (currentLayoutMode === 'grid' ? 'grid' : 'flex') : 'none'; skeletonLoaderEl.className = `file-browser-${currentLayoutMode}${show ? ' visible': ''}`; }
        function hideSkeletonLoader() { skeletonLoaderEl.style.display = 'none'; }
        function displayStatus(message, isError = false) { statusMessageEl.innerHTML = message; statusMessageEl.style.color = isError ? 'var(--accent-color)' : 'var(--text-secondary)'; statusMessageEl.classList.add('visible'); fileBrowserContainerEl.innerHTML = ''; hideSkeletonLoader(); if (itemCountDisplayEl) { itemCountDisplayEl.textContent = ''; itemCountDisplayEl.style.display = 'none';}}
        function hideLoading() { if (!statusMessageEl.style.color.includes('accent')) { statusMessageEl.classList.remove('visible'); } }

        function setMainViewMode(mode) { if (mode === currentMainView) return; currentMainView = mode; saveSetting('mainView', mode); applyMainViewMode(); searchBox.value = ''; if(searchContainer.classList.contains('active')) toggleSearch(false); showSkeletonLoader(true); fileBrowserContainerEl.innerHTML = ''; requestAnimationFrame(() => { if (mode === VIEW_MODE_FOLDER) updateDirectoryView(currentDirectory); else displayStatus("Selected view not implemented.", false); }); }
        
        function applyMainViewMode() {
            updateMainViewToggleButtons();
            updateBreadcrumbs();
            sortButtonsContainer.style.display = (currentMainView === VIEW_MODE_FOLDER) ? 'flex' : 'none';
            if (itemCountDisplayEl) {
                itemCountDisplayEl.style.display = (currentMainView === VIEW_MODE_FOLDER) ? 'inline' : 'none';
                if (currentMainView !== VIEW_MODE_FOLDER) { itemCountDisplayEl.textContent = ''; } 
                else { updateItemCountDisplay(); }
            }
        }

        function updateItemCountDisplay() {
            if (!itemCountDisplayEl || !currentDirectoryItems) { if(itemCountDisplayEl) itemCountDisplayEl.style.display = 'none'; return; }
            const items = currentDirectoryItems;
            const count = items.length;
            let text = "";
            const isSearchActive = searchBox.value.trim() !== '' && searchContainer.classList.contains('active');
            if (isSearchActive) {
                const numResults = items.length;
                text = (numResults > 0) ? `${numResults} result${numResults > 1 ? 's' : ''} found` : "No results found";
            } else {
                const numFolders = items.filter(item => item.isDirectory).length;
                const numFiles = items.filter(item => !item.isDirectory).length;
                if (numFolders > 0 && numFiles > 0) text = `${numFolders} folder${numFolders > 1 ? 's' : ''}, ${numFiles} file${numFiles > 1 ? 's' : ''}`;
                else if (numFolders > 0) text = `${numFolders} folder${numFolders > 1 ? 's' : ''}`;
                else if (numFiles > 0) text = `${numFiles} file${numFiles > 1 ? 's' : ''}`;
                else if (count === 0) text = (currentDirectory) ? "Empty folder" : "Archive empty";
            }
            itemCountDisplayEl.textContent = text;
            if (currentMainView === VIEW_MODE_FOLDER || isSearchActive) { itemCountDisplayEl.style.display = text ? 'inline' : 'none'; }
        }

        function updateMainViewToggleButtons() { folderViewBtn.classList.toggle('active', currentMainView === VIEW_MODE_FOLDER); }
        
        function setLayoutMode(mode) { 
            if (mode === currentLayoutMode) return; 
            currentLayoutMode = mode; 
            if (currentDirectory !== '') {
                sessionStorage.setItem('viewOverride-' + currentDirectory, mode);
            }
            applyLayoutMode(); 
            rerenderCurrentView(); 
        }

        function applyLayoutMode() { 
            gridViewBtn.classList.toggle('active', currentLayoutMode === 'grid'); 
            listViewBtn.classList.toggle('active', currentLayoutMode === 'list'); 
            if (fileBrowserContainerEl.children.length > 0) {
                 fileBrowserContainerEl.className = `file-browser-${currentLayoutMode}`;
            }
        }
        
        function setSortMode(mode) { if (mode === currentSortMode) return; currentSortMode = mode; saveSetting('sortMode', mode); applySortModeUI(); rerenderCurrentView(); }
        function applySortModeUI() { sortAlphaBtn.classList.toggle('active', currentSortMode === 'alphabetical'); sortYearBtn.classList.toggle('active', currentSortMode === 'year'); }
        
        function rerenderCurrentView() { 
            showSkeletonLoader(true); 
            fileBrowserContainerEl.innerHTML = ''; 
            requestAnimationFrame(() => { 
                if (searchBox.value.trim() && searchContainer.classList.contains('active')) {
                    handleSearch(); 
                } else if (currentMainView === VIEW_MODE_FOLDER) {
                    let items = getItemsInDirectory(allArchiveFiles, currentDirectory);
                    items = sortItems(items);
                    currentDirectoryItems = items;
                    renderFileBrowser(items);
                } else {
                    displayStatus("Selected view not available for rerender.", false); 
                }
            }); 
        }

        function sortItems(items) {
            return items.sort((a, b) => {
                const typeA = a.isDirectory ? 0 : (a.isAudio ? 1 : 2);
                const typeB = b.isDirectory ? 0 : (b.isAudio ? 1 : 2);
                if (typeA !== typeB) return typeA - typeB;
                if (currentSortMode === 'year') {
                    const yearA = a.year; const yearB = b.year;
                    if (yearA && yearB && yearA !== yearB) return yearB - yearA;
                    if (yearA && !yearB) return -1;
                    if (!yearA && yearB) return 1;
                }
                const nameA = a.isAudio ? a.title : a.displayName;
                const nameB = b.isAudio ? b.title : b.displayName;
                return (nameA || '').localeCompare(nameB || '', undefined, { numeric: true, sensitivity: 'base' });
            });
        }

        function updateDirectoryView(path) {
            if (currentMainView !== VIEW_MODE_FOLDER) return;
            if (isLyricsViewActive) toggleLyricsView();

            const oldPath = currentDirectory;
            currentDirectory = path;
            
            const isRoot = path === '';
            let items = getItemsInDirectory(allArchiveFiles, currentDirectory);

            if (isRoot) {
                currentLayoutMode = 'list';
            } else {
                const sessionOverride = sessionStorage.getItem('viewOverride-' + path);
                if (sessionOverride) {
                    currentLayoutMode = sessionOverride;
                } else {
                    const hasMp3s = items.some(item => item.isAudio);
                    currentLayoutMode = hasMp3s ? 'list' : SUBFOLDER_DEFAULT_VIEW;
                }
            }
            updateViewControls();
            applyLayoutMode();

            if (!isNavigatingViaPopState && oldPath !== currentDirectory) {
                history.pushState({ path: currentDirectory }, document.title, buildUrlQuery(currentDirectory));
            }
            if (oldPath !== currentDirectory && searchBox.value) {
                 searchBox.value = '';
                 if (searchContainer.classList.contains('active')) toggleSearch(false);
            }

            showSkeletonLoader(true);
            fileBrowserContainerEl.innerHTML = '';
            updateBreadcrumbs();
            
            items = sortItems(items);
            
            currentDirectoryItems = items;
            currentTracklist = items.filter(item => item.isAudio);
            currentTrackIndex = currentPlayingFile ? currentTracklist.findIndex(track => track.path === currentPlayingFile.path) : -1;
            
            updatePrevNextButtons();
            updateDownloadAllButtonState();
            updateItemCountDisplay();
            
            requestAnimationFrame(() => {
                renderFileBrowser(items);
                if (items.length > 0 && statusMessageEl.classList.contains('visible') && !statusMessageEl.textContent.toLowerCase().includes('error')) {
                     hideLoading();
                } else if (items.length === 0) {
                    displayStatus(isRoot ? `Archive empty or failed to load.` : 'This folder is empty.', false);
                }
            });
        }
        
        function getItemsInDirectory(allItems, dirPath) {
            const itemsMap = new Map();
            const dirPathLength = dirPath.length;
            const isRoot = dirPath === '';

            allItems.forEach(item => {
                if (!item.path.startsWith(dirPath) || item.path === dirPath) return;

                if (isRoot && item.isImage) return;

                const relativePath = item.path.substring(dirPathLength);
                const slashIndex = relativePath.indexOf('/');

                if (slashIndex === -1) {
                    if (!item.isDirectory) itemsMap.set(item.path, { ...item });
                } else {
                    const firstPart = relativePath.substring(0, slashIndex);
                    const subDirPath = dirPath + firstPart + '/';
                    if (!itemsMap.has(subDirPath)) {
                        let dirEntry = allItems.find(d => d.path === subDirPath && d.isDirectory);
                        if (dirEntry) {
                            itemsMap.set(subDirPath, { ...dirEntry, coverArt: coverMap.get(subDirPath) || null });
                        } else {
                            const yearMatch = firstPart.match(/\((\d{4})\)$/);
                            itemsMap.set(subDirPath, {
                                name: subDirPath, path: subDirPath, displayName: firstPart, year: yearMatch ? parseInt(yearMatch[1], 10) : null,
                                isDirectory: true, isAudio: false, isImage: false, size: 0,
                                coverArt: coverMap.get(subDirPath) || null
                            });
                        }
                    }
                }
            });

            const dirCoverArtPath = coverMap.get(dirPath);
            if (dirCoverArtPath) {
                for (const item of itemsMap.values()) {
                    if (item.isAudio && !item.coverArt) {
                        item.coverArt = dirCoverArtPath;
                    }
                }
            }
            return Array.from(itemsMap.values());
        }

        function renderFileBrowser(items) {
            fileBrowserContainerEl.innerHTML = ''; 
            fileBrowserContainerEl.className = '';
            hideSkeletonLoader();
            
            if (items.length === 0) {
                if (searchBox.value.trim() && searchContainer.classList.contains('active')) {
                    displayStatus('No results found for your search.', false);
                }
                return;
            }

            const allRenderedItems = fileBrowserContainerEl.querySelectorAll('.playing-track');
            allRenderedItems.forEach(it => it.classList.remove('playing-track'));

            if (currentLayoutMode === 'list') {
                fileBrowserContainerEl.classList.add('file-browser-list');
                renderFileBrowserList(items); 
            } else {
                fileBrowserContainerEl.classList.add('file-browser-grid');
                renderFileBrowserGrid(items);
            }

            if (currentPlayingFile) {
                const currentItemEl = fileBrowserContainerEl.querySelector(`[data-path="${CSS.escape(currentPlayingFile.path)}"]`);
                if (currentItemEl) currentItemEl.classList.add('playing-track');
            }
        }
        
        function renderFileBrowserGrid(items) {
            const isSearchMode = searchBox.value.trim() !== '' && searchContainer.classList.contains('active');
            items.forEach(item => {
                const itemEl = document.createElement('div');
                itemEl.className = 'file-item-grid';
                itemEl.dataset.path = item.path;
                
                let artworkHTML, infoText, itemClass = '', hasCover = !!item.coverArt;
                const coverUrl = item.coverArt ? `${archiveDownloadUrlBase}/${encodeURIComponent(item.coverArt)}` : '';

                const artworkContainer = document.createElement('div');
                artworkContainer.className = 'grid-item-artwork';
                
                if (item.isDirectory) {
                    itemClass = 'is-folder';
                    artworkHTML = `<img src="${coverUrl}" class="cover-art-image" style="${!hasCover ? 'display:none;' : ''}" loading="lazy" alt="Folder cover"><div class="icon-fallback folder" style="${hasCover ? 'display:none;' : ''}"><i class="fas fa-folder"></i></div>`;
                    infoText = item.year || 'Folder';
                } else if (item.isAudio) {
                    itemClass = 'is-audio';
                    artworkHTML = `<img src="${coverUrl}" class="cover-art-image" style="${!hasCover ? 'display:none;' : ''}" loading="lazy" alt="Track cover"><div class="icon-fallback music" style="${hasCover ? 'display:none;' : ''}"><i class="fas fa-music"></i></div><div class="play-overlay"><i class="fas fa-play"></i></div>`;
                    infoText = formatFileSize(item.size);
                } else if (item.isImage) {
                    itemClass = 'is-image';
                    const imageUrl = `${archiveDownloadUrlBase}/${encodeURIComponent(item.path)}`;
                    artworkHTML = `<img src="${imageUrl}" class="cover-art-image" loading="lazy" alt="Image"><div class="icon-fallback image" style="display:none;"><i class="fas fa-image"></i></div>`;
                    infoText = formatFileSize(item.size);
                } else {
                    itemClass = 'non-interactive';
                    artworkHTML = `<div class="icon-fallback"><i class="fas fa-file"></i></div>`;
                    infoText = formatFileSize(item.size);
                }
                
                itemEl.classList.add(...itemClass.split(' '));
                artworkContainer.innerHTML = artworkHTML;
                
                let jumpButtonHTML = isSearchMode ? `<button class="item-jump-to-folder-btn" title="Go to folder" data-path="${item.path}"><i class="fas fa-folder-open"></i></button>` : '';
                
                const displayName = item.title || item.displayName;

                const infoContainer = document.createElement('div');
                infoContainer.className = 'grid-item-info';
                infoContainer.innerHTML = `<div class="file-name-grid" title="Click to expand\n${displayName || item.path}">${displayName || '[No Name]'}</div><div class="file-info-grid"><span>${infoText}</span>${jumpButtonHTML}</div>`;
                
                itemEl.appendChild(artworkContainer);
                itemEl.appendChild(infoContainer);
                fileBrowserContainerEl.appendChild(itemEl);
            });
        }
        
        function renderFileBrowserList(items) { 
            const isSearchMode = searchBox.value.trim() !== '' && searchContainer.classList.contains('active');
            const isEnhancedView = items.some(item => item.isAudio) && ( (currentDirectory !== '' && !isSearchMode) || isSearchMode );

            fileBrowserContainerEl.classList.toggle('enhanced-view', isEnhancedView);

            if (isEnhancedView) {
                const header = document.createElement('div');
                header.className = 'file-item-list-header';
                header.innerHTML = `
                    <span class="file-icon-list-header" style="flex: 0 0 20px;"></span>
                    <span class="file-title-list-header" style="flex: 1 1 50%; min-width: 150px;">Title</span>
                    <span class="file-artist-list-header" style="flex: 1 1 30%; min-width: 120px;">Artist</span>
                    <div class="file-info-list-header" style="flex: 0 0 auto; min-width: 125px; display: flex; justify-content: flex-end; gap: 10px;">
                        <span class="file-duration-list" style="width: 45px; text-align:right;">Duration</span>
                        <span class="file-size-list" style="min-width: 55px; text-align:right;">Size</span>
                        <span class="file-actions-list" style="width: 28px;"></span>
                        ${isSearchMode ? `<span class="file-actions-list" style="width: 28px;"></span>` : ''}
                    </div>
                `;
                fileBrowserContainerEl.appendChild(header);
            }

            items.forEach(item => { 
                const itemEl = document.createElement('div'); 
                const isInteractive = item.isDirectory || item.isAudio || item.isImage;
                itemEl.className = `file-item-list ${isInteractive ? '' : 'non-interactive'}`; 
                if (item.isDirectory) itemEl.classList.add('is-folder');
                if (item.isAudio) itemEl.classList.add('is-audio');
                if (item.isImage) itemEl.classList.add('is-image');
                itemEl.dataset.path = item.path; 
                
                const iconClass = item.isDirectory ? 'folder' : (item.isImage ? 'image' : '');
                const iconFA = item.isDirectory ? 'fa-folder' : (item.isImage ? 'fa-image' : 'fa-music');
                const iconHTML = `<div class="file-icon-list ${iconClass}"><i class="fas ${iconFA}"></i></div>`;
                
                let nameColumnsHTML = '';
                let infoColumnsHTML = '';

                if (isEnhancedView) {
                    if (item.isAudio) {
                        nameColumnsHTML = `
                            <div class="file-title-list" title="${item.title}">${item.title || '[No Title]'}</div>
                            <div class="file-artist-list" title="${item.artist || ''}">${item.artist || '—'}</div>
                        `;
                    } else { 
                        nameColumnsHTML = `<div class="file-name-full-list" title="${item.displayName}">${item.displayName}</div>`;
                    }
                    
                    const durationHTML = item.duration ? `<span class="file-duration-list">${formatTime(item.duration)}</span>` : `<span class="file-duration-list"></span>`;
                    const sizeText = item.isDirectory ? (item.year || 'Folder') : formatFileSize(item.size);
                    const sizeHTML = `<span class="file-size-list">${sizeText}</span>`;
                    const downloadHTML = item.isAudio ? createTrackDownloadButtonHTML(item.path, item.displayName) : `<span style="width: 28px;"></span>`;
                    const jumpHTML = isSearchMode ? `<button class="item-jump-to-folder-btn" title="Go to folder" data-path="${item.path}"><i class="fas fa-folder-open"></i></button>` : '';

                    infoColumnsHTML = `<div class="file-info-list">${durationHTML}${sizeHTML}${downloadHTML}${jumpHTML}</div>`;

                } else {
                    const displayName = item.title || item.displayName;
                    nameColumnsHTML = `<div class="file-name-list" title="${displayName || item.path}">${displayName || '[No Name]'}</div>`;
                    
                    const durationHTML = item.isAudio ? `<span class="file-duration-list" data-path="${item.path}">${item.duration ? formatTime(item.duration) : '--:--'}</span>` : '';
                    const sizeText = item.isDirectory ? (item.year || 'Folder') : formatFileSize(item.size);
                    const sizeHTML = `<span class="file-size-list">${sizeText}</span>`;
                    const jumpHTML = ''; // Jump button only in search/enhanced view now
                    const downloadHTML = item.isAudio ? createTrackDownloadButtonHTML(item.path, item.displayName) : '';
                    
                    infoColumnsHTML = `<div class="file-info-list">${durationHTML}${sizeHTML}${jumpHTML}${downloadHTML}</div>`;
                }
                
                itemEl.innerHTML = iconHTML + nameColumnsHTML + infoColumnsHTML;
                fileBrowserContainerEl.appendChild(itemEl); 
            }); 
        }

        function createTrackDownloadButtonHTML(itemPath, itemDisplayName) {
            return `<button class="track-download-btn" title="Download ${itemDisplayName}" data-path="${itemPath}"><div class="btn-content-wrapper"><span class="btn-icon"><i class="fas fa-download"></i></span><svg class="circular-progress" viewBox="0 0 36 36"><circle class="progress-background" cx="18" cy="18" r="15.9155" fill="transparent" stroke-width="3.5"></circle><circle class="progress-bar-circle" cx="18" cy="18" r="15.9155" fill="transparent" stroke-width="3.5" stroke-dasharray="100" stroke-dashoffset="100"></circle></svg><span class="download-progress-text">0%</span></div></button>`;
        }
        
        function formatFileSize(bytes) { if (bytes === undefined || bytes === null || bytes < 0) return ''; if (bytes === 0) return '0 B'; if (bytes < 1024) return bytes + ' B'; const i = Math.floor(Math.log(bytes) / Math.log(1024)); const units = ['B', 'KB', 'MB', 'GB', 'TB']; const unitIndex = Math.min(i, units.length - 1); const fixedDigits = unitIndex >= 2 ? 1 : 0; return parseFloat((bytes / Math.pow(1024, unitIndex)).toFixed(fixedDigits)) + ' ' + units[unitIndex];}

        function updateBreadcrumbs() {
            directoryPathEl.innerHTML = '';
            updateViewControls();
            if (searchBox.value.trim() && searchContainer.classList.contains('active')) {
                const searchCrumbContainer = document.createElement('div');
                searchCrumbContainer.style.display = 'flex'; searchCrumbContainer.style.alignItems = 'center'; searchCrumbContainer.style.gap = '10px';
                const searchCrumb = createFolderCrumb(`Search: "${searchBox.value}"`, '', true);
                searchCrumbContainer.appendChild(searchCrumb);
                const exitSearchBtn = document.createElement('button');
                exitSearchBtn.innerHTML = '<i class="fas fa-times"></i> Exit Search'; exitSearchBtn.title = 'Clear search and return to folder view'; exitSearchBtn.className = 'exit-search-btn';
                exitSearchBtn.addEventListener('click', () => {
                    searchBox.value = '';
                    if (searchContainer.classList.contains('active')) toggleSearch(false);
                    if (currentMainView !== VIEW_MODE_FOLDER) setMainViewMode(VIEW_MODE_FOLDER);
                    else updateDirectoryView(currentDirectory);
                });
                searchCrumbContainer.appendChild(exitSearchBtn);
                directoryPathEl.appendChild(searchCrumbContainer);
            } else if (currentMainView === VIEW_MODE_FOLDER) {
                const rootCrumb = createFolderCrumb('Root', '', currentDirectory === '');
                directoryPathEl.appendChild(rootCrumb);
                const parts = currentDirectory.split('/').filter(part => part !== '');
                let pathAccumulator = '';
                parts.forEach((part, index) => {
                    pathAccumulator += part + '/'; addSeparator();
                    directoryPathEl.appendChild(createFolderCrumb(part, pathAccumulator, index === parts.length - 1));
                });
            }
        }
        function addSeparator() { const separator = document.createElement('span'); separator.className = 'directory-separator'; separator.innerHTML = '›'; directoryPathEl.appendChild(separator); }
        function createFolderCrumb(text, path, isCurrent) { const crumb = document.createElement('span'); crumb.className = `directory-crumb ${isCurrent ? 'current' : ''}`; crumb.textContent = text; if (!isCurrent) { crumb.addEventListener('click', () => updateDirectoryView(path)); } return crumb; }

        function updateViewControls() {
            const isRoot = currentDirectory === '';
            const isSearchActive = searchBox.value.trim() !== '' && searchContainer.classList.contains('active');
            gridListToggleContainer.style.display = (isRoot && !isSearchActive) ? 'none' : 'flex';
        }

        function toggleSearch(forceState) {
            const activate = forceState !== undefined ? forceState : !searchContainer.classList.contains('active');
            if (activate) {
                if (isLyricsViewActive) toggleLyricsView();
                searchContainer.classList.add('active');
                searchBox.focus();
                if (searchBox.value.trim()) handleSearch();
            } else {
                searchContainer.classList.remove('active');
                searchBox.blur();
                if (directoryPathEl.querySelector('.exit-search-btn')) {
                    updateDirectoryView(currentDirectory);
                }
            }
        }

        function handleSearch() {
            clearTimeout(searchDebounceTimeout);
            searchDebounceTimeout = setTimeout(() => {
                const searchTerm = searchBox.value.trim();
                if (searchTerm) performSearch(searchTerm);
                else updateDirectoryView(currentDirectory);
            }, SEARCH_DEBOUNCE_MS);
        }

        async function performSearch(searchTerm) {
            showSkeletonLoader(true);
            fileBrowserContainerEl.innerHTML = '';
            statusMessageEl.innerHTML = `<span class="loader"></span>Searching...`;
            statusMessageEl.classList.add('visible');

            try {
                const searchWords = searchTerm.toLowerCase().split(/\s+/).filter(word => word.length > 0);
                const results = [];
                const filesToSearch = allArchiveFiles;

                for (let i = 0; i < filesToSearch.length; i++) {
                    const file = filesToSearch[i];
                    const combinedMeta = `${(file.title || file.displayName || '').toLowerCase()} ${(file.artist || '').toLowerCase()} ${(file.album || '').toLowerCase()} ${file.path.toLowerCase()}`;
                    
                    if (searchWords.every(word => combinedMeta.includes(word))) {
                        const resultFile = { ...file };
                        
                        const dirPath = resultFile.isDirectory ? resultFile.path : resultFile.path.substring(0, resultFile.path.lastIndexOf('/') + 1);
                        const folderCover = coverMap.get(dirPath);
                        if (folderCover) {
                            resultFile.coverArt = folderCover;
                        }
                        results.push(resultFile);
                    }
                    if ((i + 1) % SEARCH_CHUNK_SIZE === 0) await new Promise(resolve => setTimeout(resolve, 0));
                }
                
                results.sort((a, b) => {
                    const aIsDir = a.isDirectory ? 0 : 1;
                    const bIsDir = b.isDirectory ? 0 : 1;
                    if (aIsDir !== bIsDir) {
                        return aIsDir - bIsDir;
                    }
                    const nameA = a.title || a.displayName || '';
                    const nameB = b.title || b.displayName || '';
                    return nameA.localeCompare(nameB, undefined, { numeric: true, sensitivity: 'base' });
                });
                
                currentDirectoryItems = results;
                currentTracklist = results.filter(item => item.isAudio);
                currentTrackIndex = currentPlayingFile ? currentTracklist.findIndex(track => track.path === currentPlayingFile.path) : -1;

                currentLayoutMode = 'list'; 
                applyLayoutMode();
                
                updatePrevNextButtons();
                updateDownloadAllButtonState();
                updateItemCountDisplay();
                updateBreadcrumbs();
                sortButtonsContainer.style.display = 'none';
                renderFileBrowser(results);

            } catch (error) {
                console.error("Search failed:", error);
                displayStatus(`Search failed. ${sanitizeErrorMessage(error.message, "performSearch")}`, true);
            } finally {
                hideSkeletonLoader();
                if (statusMessageEl.textContent.includes("Searching...")) {
                     statusMessageEl.classList.remove('visible');
                }
            }
        }

        async function getMetadataFromTags(file, arrayBuffer) { return new Promise((resolve) => { if (typeof jsmediatags === 'undefined') { resolve({}); return; } jsmediatags.read(new Blob([arrayBuffer]), { onSuccess: (tag) => resolve({ title: tag.tags.title, artist: tag.tags.artist, album: tag.tags.album, picture: tag.tags.picture }), onError: (error) => { console.warn('jsmediatags error:', file?.path, error.type, error.info); resolve({}); } }); }); }
        
        function displayMetadataInPlayer(metadata) {
            const title = metadata?.title || currentPlayingFile?.title || currentPlayingFile?.displayName || 'Unknown Title';
            const artist = metadata?.artist || currentPlayingFile?.artist || UNKNOWN_ARTIST;
            const album = metadata?.album || currentPlayingFile?.album || UNKNOWN_ALBUM;
            nowPlayingEl.textContent = title; nowPlayingEl.title = title;
            let artistAlbumText = artist === UNKNOWN_ARTIST ? album : (album === UNKNOWN_ALBUM ? artist : `${artist} • ${album}`);
            if (artist === UNKNOWN_ARTIST && album === UNKNOWN_ALBUM) artistAlbumText = 'Unknown Artist / Album';
            nowPlayingArtistAlbumEl.textContent = artistAlbumText; nowPlayingArtistAlbumEl.title = artistAlbumText;
            const pathParts = currentPlayingFile?.path?.split('/').filter(p => p); pathParts?.pop();
            nowPlayingPathEl.textContent = pathParts?.length > 0 ? pathParts.join(' / ') : '';
            nowPlayingPathEl.title = currentPlayingFile?.path || '';

            albumArtLoader.classList.remove('visible');
            albumArtIcon.classList.remove('hidden');
            albumArtImg.classList.remove('loaded', 'loading'); albumArtImg.src = ''; albumArtImg.removeAttribute('style');
            
            let coverImageUrl = null;

            if (metadata?.picture && metadata.picture.data) {
                try {
                    const { data, format } = metadata.picture; let base64String = "";
                    const chunkSize = 8192; for (let i = 0; i < data.length; i += chunkSize) base64String += String.fromCharCode.apply(null, data.slice(i, i + chunkSize));
                    const imageUrl = `data:${format};base64,${window.btoa(base64String)}`;
                    coverImageUrl = imageUrl;
                    albumArtImg.onload = function() { setTimeout(() => { this.classList.remove('loading'); this.classList.add('loaded'); albumArtIcon.classList.add('hidden'); }, 50); };
                    albumArtImg.onerror = function() { this.classList.remove('loading'); albumArtIcon.classList.remove('hidden'); };
                    albumArtImg.classList.add('loading');
                    albumArtImg.src = imageUrl;
                } catch (e) { console.error("Error processing album art:", e); albumArtIcon.classList.remove('hidden'); }
            } else if (currentPlayingFile?.coverArt) {
                 coverImageUrl = `${archiveDownloadUrlBase}/${encodeURIComponent(currentPlayingFile.coverArt)}`;
                 albumArtImg.onload = function() { setTimeout(() => { this.classList.remove('loading'); this.classList.add('loaded'); albumArtIcon.classList.add('hidden'); }, 50); };
                 albumArtImg.onerror = function() { this.classList.remove('loading'); albumArtIcon.classList.remove('hidden'); };
                 albumArtImg.classList.add('loading');
                 albumArtImg.src = coverImageUrl;
            } else {
                 albumArtIcon.classList.remove('hidden'); 
            }

            updateLyricsBackground(coverImageUrl);
        }
        function updateFileDurationInList(filePath, durationSeconds) { if (currentLayoutMode !== 'list' || !durationSeconds || !isFinite(durationSeconds)) return; const durationStr = formatTime(durationSeconds); const escapedPath = CSS.escape(filePath); const durationElement = fileBrowserContainerEl.querySelector(`.file-duration-list[data-path="${escapedPath}"]`); if (durationElement && durationElement.textContent !== durationStr) durationElement.textContent = durationStr; }

        function manageCache(filePath, data) { if (audioCache.size >= MAX_CACHE_SIZE) { const oldestPath = cacheOrder.shift(); if (oldestPath) audioCache.delete(oldestPath); } audioCache.set(filePath, { ...data, timestamp: Date.now() }); cacheOrder.push(filePath); }
        
        async function playAudioFile(file, contextTracklist) {
            if (!file || !file.isAudio) return;
            if (!audioContext) { setupAudioContext(); if (!audioContext) { alert("Audio not ready. Click page first."); return; } }

            const allItems = fileBrowserContainerEl.querySelectorAll('.playing-track');
            allItems.forEach(it => it.classList.remove('playing-track'));

            if (currentPlayingFile?.path === file.path && isPlaying && currentAudioBuffer) { await togglePlayback(); return; }
            currentTracklist = contextTracklist || [];
            if (currentPlayingFile?.path === file.path && !isPlaying && currentAudioBuffer) { await startPlayback(0); return; }

            await stopPlayback();
            currentPlayingFile = { ...file };
            currentTrackIndex = currentTracklist.findIndex(track => track.path === file.path);
            
            if (currentPlayingFile) {
                const currentItemEl = fileBrowserContainerEl.querySelector(`[data-path="${CSS.escape(currentPlayingFile.path)}"]`);
                if (currentItemEl) currentItemEl.classList.add('playing-track');
            }
            
            updatePlayerUI(true, 'Connecting...');
            albumArtLoadingPercentageEl.textContent = '0%';

            if (audioCache.has(file.path)) {
                console.log("Playing from cache:", file.path);
                const cachedData = audioCache.get(file.path); currentAudioBuffer = cachedData.buffer;
                currentPlayingFile.metadata = cachedData.metadata; currentPlayingFile.title = cachedData.metadata?.title || currentPlayingFile.title; currentPlayingFile.artist = cachedData.metadata?.artist || currentPlayingFile.artist; currentPlayingFile.album = cachedData.metadata?.album || currentPlayingFile.album; currentPlayingFile.duration = currentAudioBuffer?.duration;
                
                displayMetadataInPlayer(cachedData.metadata);
                fetchAndRenderLyrics(currentPlayingFile);
                
                if (currentAudioBuffer) { await startPlayback(0); updateFileDurationInList(file.path, currentAudioBuffer.duration); }
                else { console.error("Invalid cached buffer:", file.path); audioCache.delete(file.path); updatePlayerUI(false); displayStatus(`Error: Invalid cached audio. ${sanitizeErrorMessage("Invalid cached buffer", file.path)}`, true); await stopPlayback(true); }
                updatePrevNextButtons(); return;
            }

            updatePlayerUI(true, 'Downloading...');
            albumArtLoader.classList.add('visible'); albumArtIcon.classList.add('hidden');
            albumArtImg.classList.remove('loaded'); albumArtImg.src = ''; albumArtImg.removeAttribute('style');

            const progressCb = (percent, totalBytes, receivedBytes) => {
                if (!currentPlayingFile || file.path !== currentPlayingFile.path) return;
                let percentageText = (percent === -1) ? `${formatFileSize(receivedBytes)}` : `${Math.round(percent)}%`;
                albumArtLoadingPercentageEl.textContent = percentageText;
                const downloadStatusMsg = `Downloading... ${percentageText}`;
                if (playerState === 'super-minimized' && miniTitleEl) miniTitleEl.textContent = `DL: ${percentageText}`;
                else if (nowPlayingArtistAlbumEl.textContent.startsWith('Downloading...') || nowPlayingArtistAlbumEl.textContent.startsWith('Connecting...') || nowPlayingArtistAlbumEl.textContent.startsWith('Retrying...')) {
                     nowPlayingArtistAlbumEl.textContent = downloadStatusMsg;
                }
            };

            try {
                const arrayBuffer = await fetchWithTimeoutAndRetry({url: `${archiveDownloadUrlBase}/${encodeURIComponent(file.path)}`, isForPlayback: true, progressCallback: progressCb});
                if (!currentPlayingFile || file.path !== currentPlayingFile.path) { cleanupPlaybackResources(); return; }
                
                updatePlayerUI(true, 'Decoding...');
                if(albumArtLoadingPercentageEl && albumArtLoader.classList.contains('visible')) albumArtLoadingPercentageEl.textContent = 'Processing...';
                
                const decodedBuffer = await audioContext.decodeAudioData(arrayBuffer.slice(0));
                if (!currentPlayingFile || file.path !== currentPlayingFile.path) { cleanupPlaybackResources(); return; }
                currentAudioBuffer = decodedBuffer; currentPlayingFile.duration = currentAudioBuffer?.duration;
                
                updatePlayerUI(true, 'Reading Tags...');
                
                const tagsMetadata = await getMetadataFromTags(file, arrayBuffer);
                if (!currentPlayingFile || file.path !== currentPlayingFile.path) { cleanupPlaybackResources(); return; }

                currentPlayingFile.metadata = tagsMetadata; 
                currentPlayingFile.title = tagsMetadata?.title || currentPlayingFile.title; 
                currentPlayingFile.artist = tagsMetadata?.artist || currentPlayingFile.artist;
                currentPlayingFile.album = tagsMetadata?.album || currentPlayingFile.album;
                
                manageCache(file.path, { buffer: currentAudioBuffer, metadata: currentPlayingFile.metadata });
                
                displayMetadataInPlayer(currentPlayingFile.metadata);
                fetchAndRenderLyrics(currentPlayingFile);
                
                await startPlayback(0);
                updatePrevNextButtons();
                updateFileDurationInList(file.path, currentAudioBuffer?.duration);
            } catch (error) {
                albumArtLoader.classList.remove('visible'); albumArtIcon.classList.remove('hidden');
                if (error.name === 'AbortError') {
                    console.log(`Request for ${file.path} was aborted: ${error.message}`);
                    if (currentPlayingFile && file.path === currentPlayingFile.path) cleanupPlaybackResources();
                } else {
                    if (currentPlayingFile && file.path === currentPlayingFile.path) {
                        await stopPlayback(true);
                        displayStatus(`Error playing "${file.displayName || 'track'}". ${sanitizeErrorMessage(error.message, `Play attempt for: ${file.path}`)}`, true);
                        updatePlayerUI(false);
                    } else {
                        console.warn("Error occurred for a file no longer targeted:", file.path, error);
                    }
                }
            }
        }
        async function fetchWithTimeoutAndRetry({url, timeout = FETCH_TIMEOUT_MS, retries = MAX_RETRIES, progressCallback = null, externalSignal = null}) {
            let attempts = 0; 
            const internalController = new AbortController();
            const signal = externalSignal || internalController.signal;
            const combinedAbortHandler = () => { internalController.abort("External signal aborted"); };
            if(externalSignal) externalSignal.addEventListener('abort', combinedAbortHandler, {once: true});

            while (attempts <= retries) {
                attempts++; const timeoutId = setTimeout(() => internalController.abort("Timeout"), timeout);
                try {
                    if (signal.aborted) throw new Error("Operation aborted before starting fetch.");
                    if (attempts > 1) await new Promise(resolve => setTimeout(resolve, 500 * (attempts -1) ));
                    const response = await fetch(url, { signal }); clearTimeout(timeoutId);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status} ${response.statusText}`);
                    if (signal.aborted) throw new Error(`Aborted before body: ${signal.reason}`);

                    if (progressCallback && response.body) {
                        const contentLength = response.headers.get('content-length'); const totalBytes = contentLength ? parseInt(contentLength, 10) : 0; let receivedBytes = 0;
                        const reader = response.body.getReader(); const chunks = [];
                        if (attempts === 1 && progressCallback) progressCallback(0, totalBytes, receivedBytes);
                        while (true) {
                            if (signal.aborted) throw new Error("Fetch aborted during chunk reading.");
                            const { done, value } = await reader.read(); if (done) break; chunks.push(value); receivedBytes += value.length;
                            if (progressCallback) {
                                if (totalBytes > 0) progressCallback((receivedBytes / totalBytes) * 100, totalBytes, receivedBytes);
                                else progressCallback(-1, totalBytes, receivedBytes);
                            }
                        }
                        if (signal.aborted) throw new Error(`Aborted after body: ${signal.reason}`);
                        const combined = new Uint8Array(receivedBytes); let offset = 0;
                        for (const chunk of chunks) { combined.set(chunk, offset); offset += chunk.length; }
                        if (progressCallback) progressCallback(100, totalBytes, receivedBytes);
                        if(externalSignal) externalSignal.removeEventListener('abort', combinedAbortHandler);
                        return combined.buffer;
                    } else {
                        const arrayBuffer = await response.arrayBuffer(); if (signal.aborted) throw new Error(`Aborted after body: ${signal.reason}`);
                        if(externalSignal) externalSignal.removeEventListener('abort', combinedAbortHandler);
                        return arrayBuffer;
                    }
                } catch (error) {
                    clearTimeout(timeoutId);
                    if(externalSignal) externalSignal.removeEventListener('abort', combinedAbortHandler);
                    if (error.name === 'AbortError') throw error;
                    console.error(`Fetch error (Attempt ${attempts}):`, error);
                    if (attempts > retries) throw new Error(`Fetch failed after ${retries + 1} attempts: ${error.message}`);
                }
            }
            throw new Error(`Fetch failed unexpectedly.`);
        }
        function cleanupPlaybackResources() { clearInterval(progressUpdateInterval); progressUpdateInterval = null; if (sourceNode) { try { sourceNode.onended = null; sourceNode.disconnect(); if (isPlaying || audioContext?.state === 'running') sourceNode.stop(); } catch (e) {} sourceNode = null; } if (fetchAbortController) { fetchAbortController.abort("Playback stopped/changed"); fetchAbortController = null; } }
        
        async function startPlayback(offset = 0) { 
            if (!currentAudioBuffer || !audioContext || !gainNode) { await stopPlayback(true); return; } 
            if (audioContext.state === 'suspended') {
                try { 
                    await audioContext.resume(); 
                } catch (err) { 
                    console.error("AudioContext resume failed:", err); 
                    await stopPlayback(true);
                    displayStatus(`Could not start audio. Please interact with the page and try again.`, true);
                    return; 
                }
            }
            await _performStartPlayback(offset); 
        }

        async function _performStartPlayback(offset) {
            if (!audioContext || !currentAudioBuffer) return;
            cleanupPlaybackResources();
            sourceNode = audioContext.createBufferSource();
            sourceNode.buffer = currentAudioBuffer;
            sourceNode.playbackRate.value = currentPlaybackRate;
            sourceNode.connect(gainNode);
            const validOffset = Math.max(0, Math.min(offset, currentAudioBuffer.duration));
        
            try {
                sourceNode.start(0, validOffset);
                isPlaying = true;
                _startOffset = validOffset;
                _startTime = audioContext.currentTime;
                _pausedTime = 0;
        
                updatePlayerUI(false); 
        
            } catch (e) {
                console.error("Error starting source node:", e);
                isPlaying = false;
                await stopPlayback(true);
                displayStatus(`Playback start error. ${sanitizeErrorMessage(e.message, "SourceNode start")}`, true);
                return;
            }
        
            sourceNode.onended = handleTrackEnd;
            progressUpdateInterval = setInterval(updateProgress, 250);
            
            if (!isLyricsViewActive && playerState !== 'standard') { 
                playerState = 'standard'; 
                applyPlayerState();
                saveSetting('playerState', playerState); 
            }
        }
        
        async function stopPlayback(clearInfo = false) {
            if (isPlaying && sourceNode && audioContext) _pausedTime = getCurrentPlaybackTime();
            isPlaying = false;
            cleanupPlaybackResources();
            if (clearInfo) {
                if(isLyricsViewActive) toggleLyricsView();
                updateLyricsBackground(null);
                currentPlayingFile = null; currentAudioBuffer = null; currentTrackIndex = -1; currentLyrics = null;
                _startOffset = 0; _pausedTime = 0;
                nowPlayingEl.textContent = 'Not playing'; nowPlayingEl.title = 'Not playing';
                nowPlayingArtistAlbumEl.textContent = 'Select an MP3 file'; nowPlayingPathEl.textContent = '';
                albumArtImg.src = ''; albumArtImg.classList.remove('loaded'); albumArtIcon.classList.remove('hidden');
                albumArtLoader.classList.remove('visible');
                durationEl.textContent = '0:00'; currentTimeEl.textContent = '0:00';
                progressBar.style.width = '0%'; miniProgressBar.style.setProperty('--progress-width', '0%');
                lyricsContainer.innerHTML = '<p class="lyrics-status">Lyrics will appear here.</p>';
                lastActiveLyricIndex = -1;
                document.querySelectorAll('.playing-track').forEach(it => it.classList.remove('playing-track'));
                updatePrevNextButtons();
            }
            updatePlayerUI();
            if(!isLyricsViewActive) applyPlayerState();
        }
        async function togglePlayback() { 
            if (!currentAudioBuffer || !audioContext) return; 
            if (isPlaying) { await stopPlayback(false); }
            else { 
                const resumeTime = (_pausedTime > 0 && currentAudioBuffer && _pausedTime < currentAudioBuffer.duration) ? _pausedTime : 0; 
                await startPlayback(resumeTime); 
            } 
            if (currentPlayingFile) {
                const currentItemEl = fileBrowserContainerEl.querySelector(`[data-path="${CSS.escape(currentPlayingFile.path)}"]`);
                if(currentItemEl) currentItemEl.classList.toggle('playing-track', isPlaying);
            }
        }
        function getCurrentPlaybackTime() { if (!audioContext || !currentAudioBuffer) return 0; if (isPlaying && sourceNode && _startTime > 0) { const elapsedTime = audioContext.currentTime - _startTime; const progressedTime = elapsedTime * currentPlaybackRate; return Math.max(0, Math.min(currentAudioBuffer.duration, _startOffset + progressedTime)); } else return Math.max(0, Math.min(currentAudioBuffer?.duration || 0, _pausedTime)); }
        async function handleTrackEnd(event) { const endedNaturally = isPlaying && currentAudioBuffer && Math.abs(getCurrentPlaybackTime() - currentAudioBuffer.duration) < 0.1; if (currentAudioBuffer) _pausedTime = currentAudioBuffer.duration; _startTime = 0; const wasPlaying = isPlaying; isPlaying = false; cleanupPlaybackResources(); updateProgress(); updatePlayerUI(); if (wasPlaying && endedNaturally) await playNext(); }
        async function seekTo(time) {
            if (!currentAudioBuffer || !audioContext) return;
            const seekTime = Math.max(0, Math.min(time, currentAudioBuffer.duration));
            _pausedTime = seekTime;
            if (isPlaying) { await startPlayback(seekTime); }
            else { _startOffset = seekTime; updateProgress(); }
        }
        function seek(offsetSeconds) { if (!currentAudioBuffer || !audioContext) return; const currentPosition = getCurrentPlaybackTime(); let seekTime = currentPosition + offsetSeconds; seekTo(seekTime); }
        async function playNext() { if (!currentTracklist || currentTracklist.length === 0) return; let nextIndex = currentTrackIndex + 1; if (nextIndex >= currentTracklist.length) nextIndex = 0; if (currentTracklist[nextIndex]) await playAudioFile(currentTracklist[nextIndex], currentTracklist); else await stopPlayback(true); }
        async function playPrev() { if (!currentTracklist || currentTracklist.length === 0) return; if (getCurrentPlaybackTime() > 3 && currentTrackIndex !== -1) { await seekTo(0); return; } let prevIndex = currentTrackIndex - 1; if (prevIndex < 0) prevIndex = currentTracklist.length - 1; if (currentTracklist[prevIndex]) await playAudioFile(currentTracklist[prevIndex], currentTracklist); else await stopPlayback(true); }

        async function triggerDownload() { 
            if (!currentPlayingFile || !currentPlayingFile.path || downloadBtn.classList.contains('loading') || downloadBtn.disabled) return; 
            downloadBtn.classList.add('loading');
            try { await downloadSpecificTrack(currentPlayingFile.path, downloadBtn, currentPlayingFile.displayName, true); } 
            catch (error) { console.error("Player download failed:", error); } 
            finally { downloadBtn.classList.remove('loading'); }
        }

        async function downloadSpecificTrack(filePath, buttonElement, displayName = '', isPlayerButton = false) {
            if (!filePath || !buttonElement || buttonElement.classList.contains('loading')) return;
            if (activeDownloads.has(filePath) && activeDownloads.get(filePath).signal && !activeDownloads.get(filePath).signal.aborted) { console.log(`Download for ${filePath} already in progress.`); return; }
            const fileUrl = `${archiveDownloadUrlBase}/${encodeURIComponent(filePath)}`;
            const filename = displayName || filePath.split('/').pop() || 'download.mp3';
            const progressCircle = isPlayerButton ? null : buttonElement.querySelector('.progress-bar-circle');
            const progressTextElement = isPlayerButton ? null : buttonElement.querySelector('.download-progress-text');

            buttonElement.classList.add('loading');
            buttonElement.disabled = true;

            const radius = progressCircle ? parseFloat(progressCircle.getAttribute('r')) : 0;
            const circumference = radius ? 2 * Math.PI * radius : 100;
            if (progressCircle) {
                progressCircle.style.strokeDasharray = `${circumference} ${circumference}`;
                progressCircle.style.strokeDashoffset = circumference;
            }
            if (progressTextElement) progressTextElement.textContent = '0%';
            
            const downloadController = new AbortController();
            activeDownloads.set(filePath, downloadController);
            try {
                const buffer = await fetchWithTimeoutAndRetry({
                    url: fileUrl, externalSignal: downloadController.signal,
                    progressCallback: (percent) => {
                        if (!isPlayerButton) {
                            if (progressTextElement) progressTextElement.textContent = `${Math.round(percent)}%`;
                            if (progressCircle) progressCircle.style.strokeDashoffset = circumference - (percent / 100) * circumference;
                        }
                    }
                });
                
                if (downloadController.signal.aborted) throw new Error("Download aborted.");
                if (progressTextElement) progressTextElement.textContent = '100%';
                if (progressCircle) progressCircle.style.strokeDashoffset = 0;
                
                const blob = new Blob([buffer]);
                const blobUrl = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = blobUrl; link.download = filename;
                document.body.appendChild(link); link.click(); document.body.removeChild(link);
                setTimeout(() => URL.revokeObjectURL(blobUrl), 100);
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log(`Download aborted: ${filename}`);
                    if (progressTextElement) progressTextElement.textContent = 'X';
                } else {
                    console.error(`Download failed for ${filename}:`, error);
                    alert(`Failed to download "${filename}".\n${sanitizeErrorMessage(error.message)}`);
                    if (progressTextElement) progressTextElement.textContent = 'ERR';
                }
            } finally {
                activeDownloads.delete(filePath);
                buttonElement.classList.remove('loading');
                buttonElement.disabled = false;
                if (!isPlayerButton) {
                    setTimeout(() => {
                        if (progressCircle) progressCircle.style.strokeDashoffset = circumference;
                        if (progressTextElement) progressTextElement.textContent = '0%';
                    }, 2000);
                }
            }
        }
        
        function updatePlayerUI(isLoading = false, loadingMessage = 'Loading...') {
            const hasActiveTrack = !!currentPlayingFile; const hasBuffer = !!currentAudioBuffer; const canControl = hasActiveTrack && hasBuffer && !isLoading;
            playPauseBtn.disabled = !hasActiveTrack || isLoading || !audioContext;
            pitchSlider.disabled = !canControl;
            revertSpeedBtn.disabled = !canControl;
            downloadBtn.disabled = !hasActiveTrack || isLoading || downloadBtn.classList.contains('loading');
            jumpToFolderBtn.disabled = !hasActiveTrack;
            volumeSlider.disabled = !audioContext;
            lyricsBtn.disabled = !canControl;
            updatePrevNextButtons();

            if (miniTitleEl && playerState === 'super-minimized') {
                miniTitleEl.removeEventListener('click', expandPlayerToStandard);
                miniTitleEl.style.cursor = 'default'; miniTitleEl.title = '';
                if (isLoading) {
                    const briefMessage = loadingMessage.includes('...') ? loadingMessage.split('...')[0] : loadingMessage;
                    miniTitleEl.textContent = briefMessage;
                } else if (hasActiveTrack) {
                    miniTitleEl.textContent = currentPlayingFile.title || currentPlayingFile.displayName || "Now Playing";
                    miniTitleEl.title = miniTitleEl.textContent;
                } else {
                    miniTitleEl.innerHTML = '<i class="fas fa-headphones-alt" style="margin-right: 5px; font-size: 0.9em;"></i> Player';
                    miniTitleEl.title = "Expand Player";
                    miniTitleEl.style.cursor = 'pointer';
                    miniTitleEl.addEventListener('click', expandPlayerToStandard);
                }
            }
            if (isLoading) {
                albumArtLoader.classList.add('visible');
                albumArtIcon.classList.add('hidden');
                albumArtLoadingPercentageEl.textContent = loadingMessage.split('...')[0];
                nowPlayingEl.textContent = currentPlayingFile?.displayName || 'Loading...';
                nowPlayingArtistAlbumEl.textContent = loadingMessage;
                if (currentPlayingFile?.path) { const pathParts = currentPlayingFile.path.split('/').filter(p => p); pathParts.pop(); nowPlayingPathEl.textContent = pathParts.join(' / '); } else nowPlayingPathEl.textContent = '';
                if (playPauseIcon) playPauseIcon.className = 'fas fa-spinner fa-spin';
                durationEl.textContent = '--:--'; currentTimeEl.textContent = '--:--'; progressBar.style.width = '0%'; miniProgressBar.style.setProperty('--progress-width', '0%');
            } else if (hasActiveTrack && hasBuffer) {
                albumArtLoader.classList.remove('visible');
                if (playPauseIcon) playPauseIcon.className = isPlaying ? 'fas fa-pause' : 'fas fa-play';
                durationEl.textContent = formatTime(currentAudioBuffer.duration);
                if (nowPlayingArtistAlbumEl.textContent.includes('...')) {
                    const artist = currentPlayingFile?.artist || UNKNOWN_ARTIST;
                    const album = currentPlayingFile?.album || UNKNOWN_ALBUM;
                    let artistAlbumText = artist === UNKNOWN_ARTIST ? album : (album === UNKNOWN_ALBUM ? artist : `${artist} • ${album}`);
                    if (artist === UNKNOWN_ARTIST && album === UNKNOWN_ALBUM) artistAlbumText = 'Unknown Artist / Album';
                    nowPlayingArtistAlbumEl.textContent = artistAlbumText;
                }
                updateProgress();
            } else {
                albumArtLoader.classList.remove('visible'); albumArtImg.classList.remove('loaded'); albumArtImg.src = ''; albumArtIcon.classList.remove('hidden');
                nowPlayingEl.textContent = 'Not playing'; nowPlayingEl.title = 'Not playing'; nowPlayingArtistAlbumEl.textContent = 'Select an MP3 file';
                if (playPauseIcon) playPauseIcon.className = 'fas fa-play'; playPauseBtn.disabled = true; pitchSlider.disabled = true; revertSpeedBtn.disabled = true; downloadBtn.disabled = true; jumpToFolderBtn.disabled = true; prevBtn.disabled = true; nextBtn.disabled = true; lyricsBtn.disabled = true;
                durationEl.textContent = '0:00'; currentTimeEl.textContent = '0:00'; progressBar.style.width = '0%'; miniProgressBar.style.setProperty('--progress-width', `0%`);
            }
        }
        function updateProgress() { if (!audioContext || !currentAudioBuffer || !isFinite(currentAudioBuffer.duration)) { return; } const currentPosition = getCurrentPlaybackTime(); const duration = currentAudioBuffer.duration; currentTimeEl.textContent = formatTime(currentPosition); if(durationEl.textContent === '--:--' || durationEl.textContent === '0:00') durationEl.textContent = formatTime(duration); const progressPercent = (duration > 0) ? (currentPosition / duration) * 100 : 0; const progressWidth = `${Math.min(100, Math.max(0, progressPercent))}%`; if (progressBar.style.width !== progressWidth) progressBar.style.width = progressWidth; if (miniProgressBar.style.getPropertyValue('--progress-width') !== progressWidth) miniProgressBar.style.setProperty('--progress-width', progressWidth); if (isLyricsViewActive) updateSyncedLyrics(currentPosition); }
        function updateVolumeIcon(volume) { if (!volumeIcon) return; if (volume <= 0) volumeIcon.className = 'fas fa-volume-mute'; else if (volume < 0.5) volumeIcon.className = 'fas fa-volume-down'; else volumeIcon.className = 'fas fa-volume-up'; }
        function updatePrevNextButtons() { const canNavigate = currentTracklist && currentTracklist.length > 0 && currentTrackIndex !== -1; prevBtn.disabled = !canNavigate; nextBtn.disabled = !canNavigate; }
        
        function expandPlayerToStandard() { if (playerState !== 'standard') { playerState = 'standard'; applyPlayerState(); saveSetting('playerState', playerState); } }
        function cyclePlayerState() { if (isLyricsViewActive) return; if (playerState === 'standard') playerState = 'minimized'; else if (playerState === 'minimized') playerState = 'super-minimized'; else playerState = 'standard'; applyPlayerState(); saveSetting('playerState', playerState); }
        function applyPlayerState() {
            if (isLyricsViewActive) return;
            playerSection.classList.remove('minimized', 'super-minimized', 'standard');
            bodyEl.classList.remove('player-minimized', 'player-super-minimized', 'player-standard');
            const toggleIconEl = playerToggleBtn.querySelector('.toggle-icon i');
            playerToggleBtn.style.display = 'flex';
            if (playerState === 'minimized') {
                playerSection.classList.add('minimized'); bodyEl.classList.add('player-minimized');
                if (toggleIconEl) toggleIconEl.className = 'fas fa-angle-double-down';
                playerToggleBtn.title = "Shrink Further";
                if (miniTitleEl) miniTitleEl.textContent = (currentPlayingFile ? (currentPlayingFile.title || currentPlayingFile.displayName || "Now Playing") : "Player");
            } else if (playerState === 'super-minimized') {
                playerSection.classList.add('super-minimized'); bodyEl.classList.add('player-super-minimized');
                if (toggleIconEl) toggleIconEl.className = 'fas fa-angle-up';
                playerToggleBtn.title = "Expand Player";
            } else {
                playerSection.classList.add('standard'); bodyEl.classList.add('player-standard');
                if (toggleIconEl) toggleIconEl.className = 'fas fa-angle-down';
                playerToggleBtn.title = "Minimize Player";
                if (miniTitleEl) miniTitleEl.innerHTML = '';
            }
            const isLoadingNow = playPauseIcon && playPauseIcon.classList.contains('fa-spinner');
            updatePlayerUI(isLoadingNow, isLoadingNow ? (nowPlayingArtistAlbumEl.textContent || "Loading...") : undefined);
        }

        function formatTime(seconds) { if (isNaN(seconds) || !isFinite(seconds) || seconds < 0) return '0:00'; const totalSeconds = Math.floor(seconds); const mins = Math.floor(totalSeconds / 60); const secs = totalSeconds % 60; return `${mins}:${secs.toString().padStart(2, '0')}`; }
        function showSearchHintIfNeeded() { if (localStorage.getItem('searchHintDismissed') !== 'true') { setTimeout(() => searchHintPopup?.classList.add('visible'), 1500); } }
        function dismissSearchHint() { if (!searchHintPopup) return; searchHintPopup.style.opacity = '0'; setTimeout(() => searchHintPopup.classList.remove('visible'), 300); try { localStorage.setItem('searchHintDismissed', 'true'); } catch (e) {} }

        function toggleLyricsView() { isLyricsViewActive = !isLyricsViewActive; bodyEl.classList.toggle('lyrics-view-active', isLyricsViewActive); if (isLyricsViewActive && isPlaying) { lastActiveLyricIndex = -1; updateSyncedLyrics(getCurrentPlaybackTime()); } }
        
        function updateLyricsBackground(imageUrl) {
            if (!lyricsBackgroundEl) return;

            const currentImg = lyricsBackgroundEl.querySelector('.lyrics-bg-image');
            
            if (!imageUrl) {
                if (currentImg) {
                    currentImg.classList.remove('loaded');
                    setTimeout(() => {
                        if (lyricsBackgroundEl.contains(currentImg)) {
                            lyricsBackgroundEl.removeChild(currentImg);
                        }
                    }, 600);
                }
                return;
            }

            if (currentImg && currentImg.src === imageUrl) {
                return;
            }
            
            const newImg = document.createElement('img');
            newImg.className = 'lyrics-bg-image';
            newImg.src = imageUrl;

            newImg.onload = () => {
                if (currentImg) {
                    currentImg.classList.remove('loaded');
                    setTimeout(() => {
                        if (lyricsBackgroundEl.contains(currentImg)) {
                            lyricsBackgroundEl.removeChild(currentImg);
                        }
                    }, 600);
                }
                lyricsBackgroundEl.appendChild(newImg);
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        newImg.classList.add('loaded');
                    });
                });
            };
            newImg.onerror = () => {
                if (lyricsBackgroundEl.contains(newImg)) lyricsBackgroundEl.removeChild(newImg);
                if (currentImg) currentImg.classList.remove('loaded');
            };
        }

        async function fetchAndRenderLyrics(file) {
            currentLyrics = null;
            lyricsContainer.innerHTML = `<p class="lyrics-status"><span class="loader"></span> Searching for lyrics...</p>`;
            lyricsContainer.className = 'lyrics-container';
            lastActiveLyricIndex = -1;

            const title = file.metadata?.title || file.title;
            const artist = file.metadata?.artist || file.artist;
            const album = file.metadata?.album || file.album;
            const duration = file.duration;

            if (!artist || !title || artist === UNKNOWN_ARTIST) {
                lyricsContainer.innerHTML = `<p class="lyrics-status">Not enough info to find lyrics.</p>`;
                return;
            }

            try {
                const url = new URL(`${lyricsApiUrl}/search`);
                url.searchParams.append('track_name', title);
                url.searchParams.append('artist_name', artist);
                if (album && album !== UNKNOWN_ALBUM) {
                    url.searchParams.append('album_name', album);
                }

                const response = await fetch(url);
                if (!response.ok) throw new Error(`Lyrics API error: ${response.status}`);
                const results = await response.json();

                if (!results || results.length === 0) {
                    lyricsContainer.innerHTML = `<p class="lyrics-status">No lyrics found for this track.</p>`;
                    return;
                }

                // --- NEW & IMPROVED SCORING LOGIC ---
                let bestMatch = null;
                let highestScore = -1;

                for (const result of results) {
                    let currentScore = 0;
                    
                    // 1. Give a huge bonus for having synced lyrics, as they are preferred.
                    if (result.syncedLyrics) {
                        currentScore += 10;
                    }

                    // 2. Score based on exact metadata matches (case-insensitive).
                    if (result.artistName.toLowerCase() === artist.toLowerCase()) {
                        currentScore += 5;
                    }
                    if (result.trackName.toLowerCase() === title.toLowerCase()) {
                        currentScore += 5;
                    }
                    if (album && result.albumName && result.albumName.toLowerCase() === album.toLowerCase()) {
                        currentScore += 3;
                    }
                    
                    // 3. This is the most important part: Score based on duration proximity.
                    //    The closer the duration, the higher the score.
                    if (duration && result.duration) {
                        const durationDiff = Math.abs(duration - result.duration);
                        
                        if (durationDiff <= 1.5) {
                            // Almost perfect match, very high bonus
                            currentScore += 10;
                        } else if (durationDiff <= 5) {
                            // Close match, good bonus
                            currentScore += 5;
                        } else if (durationDiff <= 10) {
                            // Loose match, small bonus
                            currentScore += 1;
                        }
                        // We could even add a penalty for large differences, but this is usually sufficient.
                    }

                    // 4. Update the best match if the current item has a better score.
                    if (currentScore > highestScore) {
                        highestScore = currentScore;
                        bestMatch = result;
                    }
                }
                // --- END OF SCORING LOGIC ---
                
                if (!bestMatch || (!bestMatch.syncedLyrics && !bestMatch.plainLyrics)) {
                    lyricsContainer.innerHTML = `<p class="lyrics-status">No suitable lyrics found for this version.</p>`;
                    return;
                }

                // Render the lyrics from the determined best match
                if (bestMatch.syncedLyrics) {
                    currentLyrics = { synced: parseLrc(bestMatch.syncedLyrics), plain: null };
                    lyricsContainer.innerHTML = currentLyrics.synced.map(line => `<p class="lyrics-line" data-time="${line.time}">${line.text || ' '}</p>`).join('');
                    lyricsContainer.className = 'lyrics-container';
                } else if (bestMatch.plainLyrics) {
                    currentLyrics = { synced: null, plain: bestMatch.plainLyrics };
                    lyricsContainer.innerHTML = `<p class="lyrics-plain">${bestMatch.plainLyrics}</p>`;
                    lyricsContainer.className = 'lyrics-container plain-text';
                }

            } catch(error) {
                console.error("Failed to fetch lyrics:", error);
                lyricsContainer.innerHTML = `<p class="lyrics-status">Could not load lyrics.</p>`;
            }
        }

        function parseLrc(lrcText) {
            const lines = lrcText.split('\n'); const parsed = []; const timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/g;
            for (const line of lines) {
                const text = line.replace(timeRegex, '').trim(); let match; timeRegex.lastIndex = 0;
                while ((match = timeRegex.exec(line)) !== null) {
                    const time = parseInt(match[1], 10) * 60 + parseInt(match[2], 10) + parseInt(match[3].padEnd(3, '0'), 10) / 1000;
                    parsed.push({ time, text });
                }
            }
            return parsed.sort((a, b) => a.time - b.time);
        }

        function updateSyncedLyrics(currentTime) {
            if (!currentLyrics?.synced || currentLyrics.synced.length === 0) return;
            let activeIndex = -1;
            for (let i = currentLyrics.synced.length - 1; i >= 0; i--) { if (currentTime >= currentLyrics.synced[i].time) { activeIndex = i; break; } }
            if (activeIndex !== lastActiveLyricIndex) {
                const lines = lyricsContainer.querySelectorAll('.lyrics-line');
                if (lastActiveLyricIndex !== -1 && lines[lastActiveLyricIndex]) lines[lastActiveLyricIndex].classList.remove('active');
                if (activeIndex !== -1 && lines[activeIndex]) {
                    lines[activeIndex].classList.add('active');
                    lines[activeIndex].scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
                }
                lastActiveLyricIndex = activeIndex;
            }
        }

        function updateDownloadAllButtonState() {
            if (!downloadAllBtn || downloadAllBtn.classList.contains('loading')) return;
            const itemsInView = currentDirectoryItems.filter(item => item.isAudio || item.isImage);
            downloadAllBtn.disabled = itemsInView.length === 0;
            downloadAllBtn.title = itemsInView.length > 0 ? `Download ${itemsInView.length} item${itemsInView.length > 1 ? 's' : ''} as a ZIP` : "No items to download in this view";
        }

        async function triggerMultiDownload() {
            if (downloadAllBtn.classList.contains('loading')) return;
            const tracksToDownload = currentDirectoryItems.filter(item => item.isAudio);
            
            const coverPath = coverMap.get(currentDirectory);
            let coverFile = null;
            if (coverPath) {
                coverFile = allArchiveFiles.find(f => f.path === coverPath);
            }
            const itemsToDownload = [...tracksToDownload];
            if (coverFile && !itemsToDownload.some(item => item.path === coverFile.path)) {
                itemsToDownload.push(coverFile);
            }

            if (itemsToDownload.length === 0) { alert("There are no downloadable files in the current view."); return; }
            
            multiDownloadAbortController = new AbortController();
            downloadAllBtn.classList.add('loading'); downloadAllBtn.disabled = true;
            let zip = new JSZip();
            const failedFiles = [];
            const totalItems = itemsToDownload.length;

            try {
                for (const [index, item] of itemsToDownload.entries()) {
                    if (multiDownloadAbortController.signal.aborted) throw new Error("Download cancelled by user.");
                    const overallProgressText = `Downloading ${index + 1}/${totalItems}`;
                    downloadAllProgressTextEl.textContent = `${overallProgressText}...`;
                    const progressCallbackForFile = (percent, total, received) => {
                        const progressIndicator = (percent === -1) ? formatFileSize(received) : `${Math.round(percent)}%`;
                        downloadAllProgressTextEl.textContent = `${overallProgressText} (${progressIndicator})...`;
                    };
                    try {
                        const buffer = await fetchWithTimeoutAndRetry({url: `${archiveDownloadUrlBase}/${encodeURIComponent(item.path)}`, externalSignal: multiDownloadAbortController.signal, progressCallback: progressCallbackForFile});
                        zip.file(item.displayName, buffer);
                    } catch (error) { if (error.name !== 'AbortError') { console.error(`Failed to download ${item.displayName}:`, error); failedFiles.push(item.displayName); } else { throw error; }}
                }
                if (multiDownloadAbortController.signal.aborted) throw new Error("Download cancelled by user.");
                downloadAllProgressTextEl.textContent = 'Zipping files...';
                const zipBlob = await zip.generateAsync({ type: "blob", compression: "DEFLATE", compressionOptions: { level: 1 } }, (metadata) => {
                    downloadAllProgressTextEl.textContent = `Zipping: ${Math.round(metadata.percent)}%`;
                });
                if (multiDownloadAbortController.signal.aborted) throw new Error("Download cancelled during zipping.");
                let zipFileName = "archive.zip";
                if (searchBox.value.trim() !== '' && searchContainer.classList.contains('active')) zipFileName = "search-results.zip";
                else if (currentDirectory) zipFileName = `${currentDirectory.split('/').filter(p=>p).pop() || 'archive'}.zip`;
                const link = document.createElement('a');
                link.href = URL.createObjectURL(zipBlob); link.download = zipFileName;
                document.body.appendChild(link); link.click(); document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
                if (failedFiles.length > 0) alert(`Download complete, but some files failed:\n- ${failedFiles.join('\n- ')}`);
            } catch (error) {
                if (error.name === 'AbortError' || error.message.includes("cancelled")) alert("Download cancelled.");
                else { alert(`An error occurred during the download process: ${error.message}`); console.error("Multi-download failed:", error); }
            } finally {
                downloadAllBtn.classList.remove('loading'); updateDownloadAllButtonState();
                multiDownloadAbortController = null; zip = null;
            }
        }
        
        function openImageViewer(item) {
            if (!item || !item.isImage) return;
            const imageUrl = `${archiveDownloadUrlBase}/${encodeURIComponent(item.path)}`;
            imageViewerImg.src = imageUrl;
            imageViewerCaption.textContent = item.displayName;
            imageViewerDownload.href = imageUrl;
            imageViewerDownload.download = item.displayName;
            imageViewerModal.style.display = 'block';
        }
        function closeImageViewer() {
            imageViewerModal.style.display = 'none';
            imageViewerImg.src = '';
            imageViewerCaption.textContent = '';
        }

        function setupEventListeners() {
            searchToggleBtn.addEventListener('click', () => toggleSearch());
            searchBox.addEventListener('input', handleSearch);
            searchBox.addEventListener('search', () => { if (!searchBox.value.trim()) { if (directoryPathEl.querySelector('.exit-search-btn')) { updateDirectoryView(currentDirectory); } } else { handleSearch(); } });
            searchBox.addEventListener('keydown', (e) => { if (e.key === 'Enter') handleSearch(); });
            
            document.addEventListener('keydown', (e) => {
                const activeEl = document.activeElement; const isInputFocused = activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.isContentEditable);
                if (imageViewerModal.style.display === 'block' && e.key === 'Escape') { closeImageViewer(); return; }
                if (isLyricsViewActive && e.key === 'Escape') { e.preventDefault(); toggleLyricsView(); return; }
                if (e.key === '/' && !isInputFocused) { e.preventDefault(); toggleSearch(true); }
                else if (e.key === 'Escape' && searchContainer.classList.contains('active')) { e.preventDefault(); toggleSearch(false); if (!searchBox.value) updateDirectoryView(currentDirectory); }
                else if (e.code === 'Space' && !isInputFocused) { e.preventDefault(); if (!playPauseBtn.disabled) togglePlayback(); }
                else if ((e.key === 'ArrowLeft' || e.key === 'ArrowRight') && !isInputFocused && currentAudioBuffer && !e.shiftKey) { e.preventDefault(); const dir = e.key === 'ArrowLeft' ? -1 : 1; seek(dir * SEEK_TIME_SECONDS); }
                else if (e.shiftKey && e.key === 'ArrowRight' && !isInputFocused) { e.preventDefault(); if (!nextBtn.disabled) playNext(); }
                else if (e.shiftKey && e.key === 'ArrowLeft' && !isInputFocused) { e.preventDefault(); if (!prevBtn.disabled) playPrev(); }
            });
            playPauseBtn.addEventListener('click', togglePlayback); prevBtn.addEventListener('click', playPrev); nextBtn.addEventListener('click', playNext); downloadBtn.addEventListener('click', triggerDownload);
            
            jumpToFolderBtn.addEventListener('click', () => {
                if (!currentPlayingFile?.path) return;
                const pathParts = currentPlayingFile.path.split('/').filter(p => p); pathParts.pop();
                const folderPath = pathParts.join('/') + (pathParts.length > 0 ? '/' : '');
                if (searchContainer.classList.contains('active')) { toggleSearch(false); searchBox.value = ''; }
                if (isLyricsViewActive) toggleLyricsView();
                if (currentMainView !== VIEW_MODE_FOLDER) setMainViewMode(VIEW_MODE_FOLDER);
                updateDirectoryView(folderPath);
            });

            playerToggleBtn.addEventListener('click', cyclePlayerState);
            progressWrapper.addEventListener('click', (e) => { 
                if (!currentAudioBuffer || !audioContext) return;
                const rect = progressWrapper.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const ratio = Math.max(0, Math.min(1, clickX / rect.width));
                seekTo(ratio * currentAudioBuffer.duration);
            });
            volumeSlider.addEventListener('input', () => { currentVolume = parseFloat(volumeSlider.value); if (gainNode && audioContext) gainNode.gain.setTargetAtTime(currentVolume, audioContext.currentTime, 0.015); updateVolumeIcon(currentVolume); });
            volumeSlider.addEventListener('change', () => saveSetting('playerVolume', currentVolume));
            pitchSlider.addEventListener('input', () => { const newRate = parseFloat(pitchSlider.value); if (newRate === currentPlaybackRate) return; currentPlaybackRate = newRate; if (sourceNode && audioContext) { const currentTime = getCurrentPlaybackTime(); sourceNode.playbackRate.setTargetAtTime(currentPlaybackRate, audioContext.currentTime, 0.015); if (isPlaying) { _startOffset = currentTime; _startTime = audioContext.currentTime; } } });
            pitchSlider.addEventListener('change', () => saveSetting('playerRate', currentPlaybackRate));
            revertSpeedBtn.addEventListener('click', () => { currentPlaybackRate = 1.0; pitchSlider.value = currentPlaybackRate; if (sourceNode && audioContext) { const currentTime = getCurrentPlaybackTime(); sourceNode.playbackRate.setTargetAtTime(currentPlaybackRate, audioContext.currentTime, 0.015); if (isPlaying) { _startOffset = currentTime; _startTime = audioContext.currentTime; } } saveSetting('playerRate', currentPlaybackRate); });
            folderViewBtn.addEventListener('click', () => setMainViewMode(VIEW_MODE_FOLDER)); 
            gridViewBtn.addEventListener('click', () => setLayoutMode('grid')); 
            listViewBtn.addEventListener('click', () => setLayoutMode('list'));
            sortAlphaBtn.addEventListener('click', () => setSortMode('alphabetical'));
            sortYearBtn.addEventListener('click', () => setSortMode('year'));
            
            fileBrowserContainerEl.addEventListener('click', (event) => {
                const itemEl = event.target.closest('.file-item-grid, .file-item-list');
                if (!itemEl) return;
                
                const filePath = itemEl.dataset.path;
                const itemData = currentDirectoryItems.find(i => i.path === filePath);
                if (!itemData) return;

                if (event.target.closest('.track-download-btn')) {
                    event.stopPropagation();
                    const downloadButton = event.target.closest('.track-download-btn');
                    downloadSpecificTrack(filePath, downloadButton, itemData.displayName, false);
                } else if (event.target.closest('.file-name-grid')) {
                    event.stopPropagation();
                    const nameEl = event.target.closest('.file-name-grid');
                    nameEl.classList.toggle('expanded');
                } else if (event.target.closest('.item-jump-to-folder-btn')) {
                    event.stopPropagation();
                    const pathParts = filePath.split('/').filter(p => p); pathParts.pop();
                    const folderPath = pathParts.join('/') + (pathParts.length > 0 ? '/' : '');
                    toggleSearch(false); searchBox.value = ''; 
                    if (isLyricsViewActive) toggleLyricsView();
                    if (currentMainView !== VIEW_MODE_FOLDER) { setMainViewMode(VIEW_MODE_FOLDER); currentDirectory = folderPath; } 
                    else updateDirectoryView(folderPath);
                } else if (itemData.isDirectory) {
                    updateDirectoryView(itemData.path);
                } else if (itemData.isAudio) {
                    playAudioFile(itemData, currentTracklist);
                } else if (itemData.isImage) {
                    openImageViewer(itemData);
                }
            });

            closeHintBtn.addEventListener('click', dismissSearchHint);
            lyricsBtn.addEventListener('click', toggleLyricsView);
            lyricsViewCloseBtn.addEventListener('click', toggleLyricsView);
            lyricsContainer.addEventListener('click', (event) => {
                if (!currentLyrics?.synced) return;
                const lineEl = event.target.closest('.lyrics-line[data-time]');
                if (lineEl) { const time = parseFloat(lineEl.dataset.time); if (!isNaN(time)) seekTo(time); }
            });

            downloadAllBtn.addEventListener('click', triggerMultiDownload);
            downloadAllCancelBtn.addEventListener('click', (e) => { e.stopPropagation(); if (multiDownloadAbortController) multiDownloadAbortController.abort(); });
            
            imageViewerClose.addEventListener('click', closeImageViewer);
            imageViewerModal.addEventListener('click', (e) => { if(e.target === imageViewerModal) closeImageViewer(); });

            window.addEventListener('popstate', (event) => {
                isNavigatingViaPopState = true;
                if (isLyricsViewActive) toggleLyricsView();
                if (searchContainer.classList.contains('active')) { toggleSearch(false); searchBox.value = ''; }
                if (event.state && event.state.path !== undefined) {
                    if (currentMainView !== VIEW_MODE_FOLDER) { currentDirectory = event.state.path; setMainViewMode(VIEW_MODE_FOLDER); } 
                    else { updateDirectoryView(event.state.path); }
                } else { updateDirectoryView(''); }
                isNavigatingViaPopState = false;
            });

            window.addEventListener('resize', () => { if(!isLyricsViewActive) applyPlayerState(); });
        }
    </script>
</body>
</html>
